#+title: qtMUD
#+hugo_base_dir: ~/hugo/emsenn-net
#+hugo_section: /programming/qtmud
#+header-args: :noweb yes
#+todo: plan draft code document test | released
#+todo: - | cancelled
#+options: todo:t
*/qtMUD/* is a game engine for running a multi-user dimension, or /MUD/: traditionally text-interface online services, typically role-playing games.

It is in /super/-*/duper/* early development. Not only are there a tremendous amount of bugs, but the code that does work doesn't follow a unified style, has very little documentation, and is incredibly inefficient. /Sorry!/
* Bulletins
  :PROPERTIES:
  :EXPORT_HUGO_SECTION*: bulletins
  :EXPORT_HUGO_TYPE: bulletin
  :END:
** 2020
*** 2020-08 August
**** 2020-08-14 Friday
***** Overhaul wrapping up
      :PROPERTIES:
      :EXPORT_FILE_NAME: 2020-08-14-overhaul-wrapping-up
      :EXPORT_DATE: [2020-08-14 Fri 10:18]
      :END:
The latest overhaul of the code, where the relatively useless "handler" stuff was ripped out, is nearly complete.
**** 2020-08-16 Sunday
***** Name Change: Racket-MUD to qtMUD
      :PROPERTIES:
      :EXPORT_DATE: [2020-08-16 Sun 10:24]
      :EXPORT_FILE_NAME: 2020-08-16-name-change-racket-mud-to-qtmud
      :END:
I'm changing the name of the project to qtMUD, for the "/qualities/ of /things/ MUD," which is an accurate description of how the MUD works. And, it's a homonym with "cutie MUD" which is, well, cute.
* Documentation
  :PROPERTIES:
  :EXPORT_HUGO_SECTION*: documentation
  :END:
** qtMUD Overview
   :PROPERTIES:
   :EXPORT_FILE_NAME: qtmud-overview
   :END:
** Developers Guide
As qtMUD is right now just being developed by me, the developer's guide is going to, for now, be a list of rules. Maybe as it grows they'll be sorted into contexts.

1. Never assume a thing is part of a universe
2. When you want to do something, see if the thing or its universe has a procedure for it.
3. Keep your manipulation of things as atomic as possible, so that your procedures can be referenced by other parts of the library.
* Engine Code
  :PROPERTIES:
  :header-args: :noweb yes
  :EXPORT_FILE_NAME: engine
  :END:
#+toc: headlines 2 local
Like many MUDs that have come before it, qtMUD divides its code up into an engine (documented below) and a [[../library/][library]] of components. See the [[../documentation/qtmud-overview/][/qtMUD Overview/]] for an explanation of how these parts relate.

Explaining how the qtMUD engine works is best done by looking at its name: it's the "qt" MUD: that stands for /qualities of things/:

The things that exist within the MUD: player-characters, items, game areas, are all /things/, possessing different /qualities/.
** Thing
#+name: thing-struct
#+begin_src racket
  (struct thing (name universe grammar qualities procedures) #:mutable)
#+end_src
*** Creating things
The =create-thing= procedure is simply an interface for the =thing= struct, coming with some defaults for filling out the mud (=#f=), grammar, and qualities (empty hash-tables).
 #+name: create-thing-procedure
 #+caption: qtMUD's =create-thing= procedure: creates a new thing.
 #+begin_src racket :noweb no-export
   (define (create-thing [name "thing"] [chosen-universe #f]
		       #:grammar [grammar #f] #:qualities [qualities #f]
		       #:procedures [procedures #f])
     (log-info "Creating a new thing named ~a~a"
	       name
	       (cond [chosen-universe
		      (format "for ~a."
			      (universe-name chosen-universe))]
		     [else "."]))
     (let ([created-thing (thing name chosen-universe
				 (cond [grammar (make-hash grammar)]
				       [else (make-hash)])
				 (cond [qualities (make-hash qualities)]
				       [else (make-hash)])
				 (cond [procedures (make-hash procedures)]
				       [else (make-hash)]))])
       (when chosen-universe
	 (add-thing-to-universe-things! created-thing chosen-universe))
       created-thing))
 #+end_src
*** Working with a Thing
**** Universe
#+name: thing-has-universe?-procedure
#+begin_src racket
  (define (thing-has-universe? queried-thing)
    (cond [(thing-universe queried-thing) #t][else #f]))
#+end_src
**** Qualities
***** thing-has-quality?
      :PROPERTIES:
      :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure for reading a quality from a qtMUD thing."
      :EXPORT_FILE_NAME: thing-has-quality?
      :EXPORT_HUGO_TYPE: racket-procedure
      :END:
  #+name: thing-has-quality?-procedure
  #+begin_src racket :noweb no-export
    (define (thing-has-quality? queried-thing queried-quality)
      (let ([queried-thing-name (thing-name queried-thing)]
	    [queried-thing-universe
	     (cond [(thing-has-universe? queried-thing)
		    (thing-universe queried-thing)]
		   [else #f])])
	(log-debug "Checking if ~a has ~a quality."
		 queried-thing-name queried-quality)
	(let ([thing-has-quality?-procedure-key
	       (join-list-of-strings-and-symbols-as-symbol
		(list "thing-has-" queried-quality "?"))])
	(cond [(thing-has-procedure? thing-has-quality?-procedure-key)
	       (log-debug "~a has a procedure for checking itself for ~a quality; using it."
			  queried-thing-name queried-quality)
	       ((thing-procedure queried-thing thing-has-quality?-procedure-key))]
	      [(and queried-thing-universe
		    (universe-has-procedure? queried-thing-universe
					     thing-has-quality?-procedure-key))
	       (log-debug "~a's universe, ~a, has a procedure for checking if ~a has ~a quality; using it."
			  queried-thing-name (universe-name queried-thing-universe)
			  queried-quality)
	       ((universe-procedure queried-thing-universe
				    thing-has-quality?-procedure-key)
		queried-thing)]
	      [else
	       (let ([queried-thing-qualities (thing-qualities queried-thing)])
		 (cond [(hash-has-key? queried-thing-qualities queried-quality)
			#t]
		       [else #f]))]))))
  #+end_src
***** thing-quality
      :PROPERTIES:
      :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure for reading a quality from a qtMUD thing."
      :EXPORT_FILE_NAME: thing-quality
      :EXPORT_HUGO_TYPE: racket-procedure
      :END:
  #+name: thing-quality-procedure
  #+begin_src racket :noweb no-export
    (define (thing-quality queried-thing queried-quality)
      (define queried-thing-name (thing-name queried-thing))
      (define queried-thing-universe
	(cond [(thing-has-universe? queried-thing)
	       (thing-universe queried-thing)]
	      [else #f]))
      (log-debug "Checking the value of ~a's ~a quality."
		 queried-thing-name queried-quality)
      (let ([thing-quality-procedure-key
	     (join-list-of-strings-and-symbols-as-symbol
	      (list "thing-" queried-quality))])
	(cond [(thing-has-procedure? thing-quality-procedure-key)
	       (log-debug "~a has a procedure for checking the value of its own ~a quality: using it."
			  queried-thing-name queried-quality)
	       ((thing-procedure queried-thing thing-quality-procedure-key)
		queried-thing)]
	      [(and queried-thing-universe
		    (universe-has-procedure? queried-thing-universe
					     thing-quality-procedure-key))
	       (log-debug "~a's universe, ~a, has a procedure for checking the value of ~a's ~a quality: using it."
			  queried-thing-name
			  (universe-name queried-thing-universe)
			  queried-quality)
	       ((universe-procedure queried-thing-universe thing-quality-procedure-key)
		queried-thing-name)]
	      [else
	       (cond [(thing-has-quality? queried-thing queried-quality)
		      (hash-ref (thing-qualities queried-thing) queried-quality)]
		     [else (error "~a doesn't have the ~a quality."
				  queried-thing-name queried-quality)])])))
  #+end_src
***** set-thing-quality!
      :PROPERTIES:
      :EXPORT_FILE_NAME: set-thing-quality!
      :EXPORT_HUGO_TAGS: "qtMUD"
      :EXPORT_HUGO_TYPE: procedure
      :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure to set a qtMUD thing's quality to a new value."
      :END:
   #+name: set-thing-quality!-procedure
   #+begin_src racket :noweb no-export
     (define (set-thing-quality! changed-thing changed-quality new-value)
       (let ([changed-thing-name (thing-name changed-thing)]
	     [changed-thing-universe
	      (cond [(thing-has-universe? changed-thing)
		     (thing-universe changed-thing)]
		    [else #f])]
	     [set-thing-quality!-procedure-key
	      (join-list-of-strings-and-symbols-as-symbol
	       (list "set-thing-" changed-quality "!"))])
	 (log-debug "Setting ~a's ~a quality to ~a."
		    changed-thing-name changed-quality new-value)
	 (cond [(thing-has-procedure? set-thing-quality!-procedure-key)
		(log-debug "~a has a procedure for setting its own ~a quality: using it."
			   changed-thing-name changed-quality)
		((thing-procedure changed-thing set-thing-quality!-procedure-key)
		 new-value)]
	       [(and changed-thing-universe
		     (universe-has-procedure? changed-thing-universe
					      set-thing-quality!-procedure-key))
		(log-debug "~a's universe, ~a, has a procedure for setting ~a's ~a quality: using it."
			   changed-thing-name
			   (universe-name changed-thing-universe)
			   changed-quality)
		((universe-procedure changed-thing-universe
				     set-thing-quality!-procedure-key)
		 changed-thing new-value)]
	       [else
		(let ([changed-thing-qualities (thing-qualities changed-thing)])
		  (cond [(hash-has-key? changed-thing-qualities changed-quality)
			 (hash-set! changed-thing-qualities changed-quality new-value)]
			[else (error "~a doesn' thave the ~a quality."
				     changed-thing-name)]))])))
   #+end_src
***** add-string-to-thing-quality!
   #+name: add-string-to-thing-quality!-procedure
   #+begin_src racket :noweb no-export
     (define (add-string-to-thing-quality! input-string changed-thing changed-quality)
       (let ([changed-thing-name (thing-name changed-thing)]
	     [changed-thing-universe
	      (cond [(thing-has-universe? changed-thing)
		     (thing-universe changed-thing)]
		    [else #f])]
	     [procedure-key
	      (join-list-of-strings-and-symbols-as-symbol
	       (list "add-string-to-thing-" changed-quality "!"))])
	 (cond [(thing-has-procedure? procedure-key)
		((thing-procedure changed-thing procedure-key) input-string)]
	       [(and changed-thing-universe
		     (universe-has-procedure? changed-thing-universe
					      procedure-key))
		((universe-procedure changed-thing-universe procedure-key)
		 changed-thing input-string)]
	       [else
		(set-thing-quality! changed-thing
				    changed-quality
				    (string-join
				     (thing-quality changed-thing changed-quality)
				     input-string))])))
   #+end_src
**** Procedures
#+name: thing-procedure-procedure
#+begin_src racket :noweb yes
  (define (thing-procedure queried-universe queried-procedure)
    (cond [(universe-has-procedure? queried-universe queried-procedure)
	   (hash-ref (thing-procedures queried-universe) queried-procedure)]
	  [else
	   (log-warning "Tried to use procedure ~a from universe ~a, but it doesn't exist."
			queried-procedure
			(universe-name queried-universe))]))
#+end_src
#+name: thing-has-procedure?-procedure
#+begin_src racket
  (define (thing-has-procedure? queried-thing queried-procedure)
    (cond [(hash-has-key? (thing-procedures queried-thing) queried-procedure) #t]
          [else #f]))
#+end_src
*** Working with a group of Things
**** list-thing-names
     :PROPERTIES:
     :EXPORT_FILE_NAME: add-ecoregions-quality-to-thing
     :EXPORT_DATE: [2020-08-12 Wed 12:42]
     :EXPORT_HUGO_TAGS: "qtMUD"
     :EXPORT_HUGO_TYPE: procedure
     :END:
  #+name: list-thing-names-procedure
  #+caption: Add a thing to another's ecoregions.
  #+begin_src racket :noweb no-export
    (define (list-thing-names things)
      (oxfordize-list
       (map
	(λ (this-thing)
	  (thing-name this-thing))
	things)))
  #+end_src
** Universe
#+name: universe-struct
#+begin_src racket
  (struct universe (name tick-count schedule things procedures) #:mutable)
#+end_src
*** Making a Universe
#+name: make-universe-procedure
#+begin_src racket :noweb yes
(define (make-universe [name "qtVerse"] [events '()])
  (log-info "Making a new universe named ~a" name)
  (universe name 0 events (list) (make-hash)))
#+end_src
*** Working with a Universe
**** Tick Count
***** increment-universe-tick-count!
  #+name: increment-universe-tick-count!-procedure
  #+begin_src racket :noweb yes
  (define (increment-universe-tick-count! incremented-universe [addition 1])
    (set-universe-tick-count!
      incremented-universe (+ (universe-tick-count incremented-universe) addition)))
  #+end_src
**** Schedule
***** add-event-to-universe-schedule!
  #+name: add-event-to-universe-schedule!-procedure
  #+begin_src racket :noweb yes
    (define (add-event-to-universe-schedule! new-event changed-universe)
      (cond [(procedure? new-event)
	     (set-universe-schedule! changed-universe (append (universe-schedule changed-universe) (list new-event)))]
	    [else
	     (log-warning "Tried to schedule non-procedure as event: ~a" new-event)]))
  #+end_src
***** add-thing-to-universe-things!
  #+name: add-thing-to-universe-things!-procedure
  #+begin_src racket :noweb yes
    (define (add-thing-to-universe-things! new-thing changed-universe)
      (set-universe-things! changed-universe (append (universe-things changed-universe) (list new-thing))))
  #+end_src
**** Procedures
***** universe-has-procedure?
#+name: universe-has-procedure?-procedure
#+begin_src racket
(define (universe-has-procedure? queried-universe queried-procedure)
  (hash-has-key? (universe-procedures queried-universe) queried-procedure))
#+end_src
***** universe-procedure
#+name: universe-procedure-procedure
#+begin_src racket :noweb yes
  (define (universe-procedure queried-universe queried-procedure)
    (cond [(universe-has-procedure? queried-universe queried-procedure)
	   (hash-ref (universe-procedures queried-universe) queried-procedure)]
	  [else
	   (log-warning "Tried to use procedure ~a from universe ~a, but it doesn't exist."
			queried-procedure
			(universe-name queried-universe))]))
#+end_src
***** set-universe-procedure!
#+name: set-universe-procedure!-procedure
#+begin_src racket :noweb yes
  (define (set-universe-procedure! changed-universe new-procedure-key new-procedure)
    (hash-set!
     (universe-procedures
      changed-universe)
     new-procedure-key
     new-procedure))
#+end_src
*** Making a Universe Tick
**** tick-universe
 #+name: tick-universe-procedure
 #+begin_src racket :noweb yes
   (define (tick-universe ticked-universe)
     (increment-universe-tick-count! ticked-universe)
     (log-debug "Universe ~a is beginning its tick, count #~a" (universe-name ticked-universe) (universe-tick-count ticked-universe))
     (let ([events-this-tick (universe-schedule ticked-universe)])
       (log-debug "Universe ~a is ticking, looking at events: ~a" (universe-name ticked-universe) events-this-tick)
       (set-universe-schedule! ticked-universe '())
       (let loop ()
	 (unless (null? events-this-tick)
	   (let ([current-event (car events-this-tick)])
             (log-debug "Universe ~a is ticking, looking at event: ~a" (universe-name ticked-universe) current-event)
	     (set! events-this-tick (cdr events-this-tick))
	     (let ([event-result (current-event ticked-universe)])
	       (when (universe? event-result) (set! ticked-universe event-result))))
	   (loop))))
     (log-debug "Universe ~a has ended its tick, count #~a" (universe-name ticked-universe) (universe-tick-count ticked-universe))
     ticked-universe)
 #+end_src
**** run-universe
 #+name: run-universe-procedure
 #+begin_src racket :noweb yes
   (define (run-universe running-universe [tick-rate 200])
     (thread
      (λ () (let loop ()
	      (set! running-universe (tick-universe running-universe))
	      (sleep 0.2)
	      (loop)))))
 #+end_src
old:
 #+begin_src racket :noweb yes
   (define (run-universe running-universe [tick-rate 200])
     (define time-of-last-tick (current-inexact-milliseconds))
     (thread
      (λ ()
	(let loop ()
 ;	 (log-debug "CIM/tick difference is ~a"
 ;		    (- (current-inexact-milliseconds) time-of-last-tick))
	  (when (> (- (current-inexact-milliseconds) time-of-last-tick) tick-rate)
 ;	   (log-debug "Triggering tick of ~a" (universe-name running-universe))
            (set! running-universe (tick-universe running-universe))
	    (set! time-of-last-tick (current-inexact-milliseconds)))
	  (loop)))))
 #+end_src
** Utilities
*** Join list of strings and symbols as symbol
#+name: join-list-of-strings-and-symbols-as-symbol-procedure
#+begin_src racket
  (define (join-list-of-strings-and-symbols-as-symbol
	   unjoined-list string-separator)
    (string-join
     (map (λ (list-element)
	    (cond [(string? list-element) list-element]
		  [(symbol? list-element) (symbol->string list-element)]))
	  unjoined-list)
     string-separator))
#+end_src
*** Oxfordize list
 #+name: oxfordize-list-procedure
 #+begin_src racket :noweb yes
 (define (oxfordize-list strings)
   (cond
     [(null? strings)
      (log-warning "Tried to oxfordize an empty list.")]
     [(null? (cdr strings))
      (car strings)]
     [(null? (cddr strings))
      (string-join strings " and ")]
     [else
      (string-join strings ", "
                   #:before-first ""
                   #:before-last ", and ")]))
 #+end_src
*** Deserialize file
    :PROPERTIES:
    :EXPORT_FILE_NAME: deserialize-file
    :END:
#+name: deserialize-file-procedure
#+begin_src racket :noweb no-export
  (define (deserialize-file save-file)
    (when (file-exists? save-file)
      (log-debug "Deserializing file ~a" save-file)
      (with-handlers
	([exn:fail:filesystem:errno?
	  (λ (E) (log-warning "Failed to deserialize file: ~a" E))])
	(with-input-from-file save-file (λ () (deserialize (read)))))))
#+end_src
*** Make universe logger
#+name: make-universe-logger-procedure
#+begin_src racket
  (define (make-universe-logger logging-universe [loglevel 'info])
    (define universe-log
      (make-logger (string->symbol (universe-name logging-universe))))
    (define universe-log-receiver
      (make-log-receiver universe-log loglevel))
    (cons universe-log universe-log-receiver))
#+end_src
*** Run universe logger
#+name: run-universe-logger-procedure
#+begin_src racket
  (define (run-universe-logger universe-logger)
    (let ([universe-log (car universe-logger)]
	  [universe-log-receiver (cdr universe-logger)])
      (current-logger universe-log)
      (thread (λ ()
		(let log-loop ()
		  (define log-vector (sync universe-log-receiver))
		  (let ([log-level (vector-ref log-vector 0)]
			[log-string (substring
				     (vector-ref log-vector 1)
				     12
				     (length (string->list
					      (vector-ref log-vector 1))))])
		    (cond[ (eq? log-level 'debug)
			   (printf ">>> \"~a\"\n"
				   log-string)]
			  [else
			   (printf "\"~a\"\n" log-string)]))
		  (log-loop))))))
#+end_src

* Library Code
  :PROPERTIES:
  :header-args: :noweb yes
  :EXPORT_FILE_NAME: library
  :END:
#+toc: headlines 1 local
** document MUDSocket
   :PROPERTIES:
   :EXPORT_FILE_NAME: mudsocket
   :END:
*** make-mudsocket-tick-event-for-universe
#+name: make-mudsocket-tick-event-for-universe
#+begin_src racket :noweb yes
  (define (make-mudsocket-commands-for-thing target-thing)
    (make-hash))

  (define (make-mudsocket-parser-for-thing target-thing)
   (λ (input-line) (void)))

  (define (make-mudsocket-sender-for-thing target-thing)
   (λ () (void)))

  (define (change-thing-into-mudsocket-client! changed-thing
					    in out ip port)
    (map (λ (quality-pair)
	   (set-thing-quality! changed-thing
			       (car quality-pair) (cdr quality-pair)
			       #t))
	 `((mudsocket-in . ,in)
	   (mudsocket-out . ,out)
	   (mudsocket-ip . ,ip)
	   (mudsocket-port . ,port)
	   (mudsocket-commands . ,(make-mudsocket-commands-for-thing
				   changed-thing))
	   (mudsocket-output-buffer . "")
	   (mudsocket-parser . ,(make-mudsocket-parser-for-thing
				 changed-thing))
	   (mudsocket-sender . ,(make-mudsocket-sender-for-thing
				 changed-thing))
	   (talker-channels . ("cq")))))

  (define (make-mudsocket-tick-event-for-universe target-universe [port 4242])
    (log-debug "Making a MUDSocket tick event for ~a." (universe-name target-universe))
    (define mudsocket-listener (tcp-listen port 5 #t))
    (define current-connections '())
    (define (tick-mudsocket-event ticked-universe)
      (define (accept-new-connection)
	(define-values (mudsocket-in mudsocket-out)
	  (tcp-accept mudsocket-listener))
	(define-values (local-ip local-port remote-ip remote-port)
	  (tcp-addresses mudsocket-in #t))
	(log-info "MUDSocket accepted a new connection from ~a:~a"
		  remote-ip remote-port)
	(define connected-thing (create-thing "MUDSocket client" ticked-universe))
	(change-thing-into-mudsocket-client! connected-thing
					   mudsocket-in mudsocket-out
					   remote-ip remote-port)
	(set! current-connections (append (list connected-thing) current-connections))
	(add-thing-to-universe-things! connected-thing ticked-universe)
	(when (universe-has-procedure? ticked-universe 'handle-mudsocket-connection)
	  ((universe-procedure ticked-universe 'handle-mudsocket-connection)
	   connected-thing))
	(add-string-to-thing-quality!
	 (cond [(universe-has-procedure? ticked-universe
					 'make-mudsocket-connection-message)
		((universe-procedure ticked-universe
				     'make-mudsocket-connection-message)
		 connected-thing)]
	       [else
		(format "Your connection to ~a has been accepted."
			(universe-name ticked-universe))])
	 connected-thing 'mudsocket-output-buffer))
      (map
       (λ (connected-thing)
	 (let ([connected-thing-name
		(thing-name connected-thing)]
	       [connected-thing-mudsocket-in
		(thing-quality connected-thing 'mudsocket-in)]
	       [connected-thing-mudsocket-out
		(thing-quality connected-thing 'mudsocket-out)]
	       [connected-thing-mudsocket-ip
		(thing-quality connected-thing 'mudsocket-thing)]
	       [connected-thing-mudsocket-port
		(thing-quality connected-thing 'mudsocket-port)]
	       [connected-thing-mudsocket-output-buffer
		(thing-quality connected-thing 'mudsocket-output-buffer)]
	       [connected-thing-mudsocket-parser
		(thing-quality connected-thing 'mudsocket-parser)]
	       [connected-thing-mudsocket-sender
		(thing-quality connected-thing 'mudsocket-sender)])
	   (define (disconnect)
	     (close-input-port connected-thing-mudsocket-in)
	     (close-output-port connected-thing-mudsocket-out)
	     (set! current-connections (remove connected-thing current-connections))
	     (log-info "MUDSocket disconnected connection from ~a:~a"
		       connected-thing-mudsocket-ip
		       connected-thing-mudsocket-port))
	   ; todo: add ^-- (destroy-thing connected-thing) above
	   (cond
	     [(port-closed? connected-thing-mudsocket-in)
	      (disconnect)]
	     [(byte-ready? connected-thing-mudsocket-in)
	      (with-handlers
		  ([exn:fail:read?
		    (λ (e) (log-warning "MUDSocket encountered issue with ~a: ~a"
					connected-thing-name
					e))]
		 [exn:fail:network:errno?
		  (λ (e) (log-warning "MUDSocket encountered issue with ~a: ~a"
				      connected-thing-name
				      e))])
		(let ([connected-thing-line-in
		       (read-line connected-thing-mudsocket-in)])
		  (cond [(string? connected-thing-line-in)
			 (connected-thing-mudsocket-parser
			  (string-trim connected-thing-line-in))]
			[(eof-object? connected-thing-line-in)
			 (disconnect)])))])
		(when (> (string-length connected-thing-mudsocket-output-buffer) 0)
		  (connected-thing-mudsocket-sender))))
       current-connections)
      (when (tcp-accept-ready? mudsocket-listener)
	(accept-new-connection))
      (add-event-to-universe-schedule! tick-mudsocket-event ticked-universe))
    (set-universe-procedure! target-universe 'list-mudsocket-current-connections
			     (λ () current-connections))
    tick-mudsocket-event)


#+end_src
* MUDs
  :PROPERTIES:
  :header-args: :noweb yes
  :END:
** draft Johara-MUD
   :PROPERTIES:
   :EXPORT_FILE_NAME: johara-mud
   :END:
The */Johara-MUD/* is the first MUD world written for the qtMUD engine. It's created through a series of declarations that make objects, modify them, and establish relationships. The following sections divide those declarations into a rough chronology, though much of the universe was created (from an in-universe perspective) in the first moment of time.
*** Creation
**** Creation of the Joharaverse
#+name: johara-mud-declarations-creation
#+begin_src racket
  (define joharaverse (make-universe "Joharaverse"))
  (run-universe-logger (make-universe-logger joharaverse))
  (set-universe-procedure!
   joharaverse 'handle-mudsocket-connection
   (λ (connected-thing)
     (add-string-to-thing-mudsocket-output-buffer!
     "Welcome to Johara settlement, weary traveler. Enter your [desired] user-name and press ENTER to connect [or register a new account]."
     connected-thing))
  (set-universe-procedure!
   joharaverse 'handle-mudsocket-login
   (λ (connected-thing)
     (add-string-to-thing-mudsocket-output-buffer!
     "You rise up from the soil of Johara Forest, just outside the settlement, and wander inside."
     connected-thing))
#+end_src
**** Creation of the game areas
***** Establishment of spatial relationships betwen game areas
#+name: johara-mud-declarations
#+begin_src racket
  ; wee universe
  ; make the areas
  (define make-thing
    (make-thing-maker-for-universe joharaverse))
  (define johara-forest-east
    (make-thing "Johara Forest, east"))
  (define johara-forest-west
    (make-thing "Johara Forest, west"))
  (define johara-settlement
    (make-thing "Johara settlement"))
  (define coastwatch-road
    (make-thing "Coastwatch Road"))
  (define meri-marshes
    (make-thing "Meri Marshes"))
  ; set up spatial relationships
;  (set-thing-area-exits!
;   johara-settlement
;   (list
;    (cons "forest" johara-forest-west)))
;  (set-thing-area-exits!
;   johara-forest-west
;   (list
;    (cons "east" johara-forest-east)
;    (cons "road" coastwatch-road)))
;  (set-thing-area-exits!
;   johara-forest-east
;   (list
;    (cons "west" johara-forest-west)))
;  (set-thing-area-exits!
;   coastwatch-road
;   (list
;    (cons "north" johara-forest-west)
;    (cons "marshes" meri-marshes)))
  ; add descriptions
;  (set-thing-area-description!
;   johara-settlememnt
;   "This is Johara settlement, a village of about 350 people living in timber and plaster buildings. It is situated in Johara Forest, on the southern slope of the Meri Mountains.")
;  (set-thing-area-description!
;   johara-forest-east
;   "")
;  (set-thing-area-description!
;   johara-forest-west
;   "")
;  (set-thing-area-description!
;   coastwatch-road
;   "")
;  (set-thing-area-description!
;   meri-marshes
;   "")
  ; make the humans that live in johara settlement
;  (define johara-resident (make-thing "Human resident of Johara"))
  ; move the humans into Johara settlement
;  (set-thing-settlement-populations!
;   johara-settlement
;   (list
;    (cons johara-resident 366)))
  ; add facilities to the settlement
  ; make plants for the forest
  ; make animals for the forest
  ; move them in
#+end_src

*** Addition of MUD basics
#+name: johara-mud-declarations-addition-of-mud-basics
#+begin_src racket
(add-event-to-universe-schedule! (make-mudsocket-tick-event-for-universe joharaverse) joharaverse)
(add-event-to-universe-schedule! (add-user-accounts-to-universe!-event) joharaverse)
#+end_src
*** Start of time
#+name: johara-mud-declarations-start-of-time
#+begin_src racket
(define johara-mud (run-universe joharaverse))
#+end_src
* Logs
  :PROPERTIES:
  :EXPORT_HUGO_SECTION*: logs
  :EXPORT_HUGO_TYPE: log
  :END:
- 2002
  - Started with the Discworld MUD library that was publicly accessible at that time.
  - Quickly switched to Dead Souls
- 2004
  - Tried to use pure FluffOS and build up from that.
- 2007
  - Decided to start my own MUD engine, in Pike.
- 2009
  - Switched to Sapidlib
- 2010
  - Tried to build another FluffOS-based library.
- 2013
  - Started my own MUD engine in Python, called qtMUD, for "quality of things"
- 2019
  - Started my own MUD engine in Elisp, but quickly switched to Racket
  - Worked on the Racket codebase from early October until late November.
- 2020
  - July :: Picked back up the Racket codebase, but realized it was really clunky. Started on a rewrite.
  - August :: Started another rewrite, mid-rewrite. Then another.
** 2020
#+toc: headlines 3 local
*** 2020-08 August
**** 2020-08-12 Wednesday
***** [2020-08-12 Wed 22:24]
Alright so I basically got frustrated at the rather useless handler system that was littering everything up, so I started writing the whole Racket-MUD over again, again.

My re-write so far has focused on the things part of things, because I got just... tired of working with the server part of things. I'll pick it back up soon.

As is, I've written out some procedures for making things and interacting with their qualities, and some procedures for two companion qualities: /bioregions/ and /parent bioregion/.

I wrote in earlier logs that one of the first things I'd like to allow for is animate things that can collect blackberries.

So, rabbits and blackberries. =(make-thing-eat-food rabbit blackberry)=

This should

1) Make sure the rabbit has the action points to do the thing
2) make sure the rabbit will at blackberries (on a list familiar foods)
   1) unless forced
3) destroy the blackberry
4) give some action points to the rabbit
   1) look at the blackberry's nutritional value
   2) and the rabbit's metabolism needs

#+begin_src racket
(define rabbit (make-thing "rabbit"))
(define blackberry (make-thing "blackberry"))
(set-thing-metabolism! rabbit (make-small-mammal-metabolism))
(set-thing-nutrition! blackberry (list (cons 'sugar 1.2)))
(make-thing-eat-food! rabbit blackberry)
#+end_src
**** 2020-08-13 Thursday
***** [2020-08-13 Thu 08:42]
Yesterday I took the day to do some fun work, making procedures for the /bioregions/ and /parent-bioregion/ thing. I'm not entirely sure what the implications of those qualities will be, how they'll be used in gameplay, but establishing some basic types of areas seemed like a nice first step. (I mean, even on their own, knowing that Teraum is the parent bioregion of the Barmland provides some sense of orientation.

Today I'd like to get back to looking at the MUD engine/server itself, now that I've abandoned the pretense of even partially following a functional programming paradigm.
**** 2020-08-14 Friday
***** [2020-08-14 Fri 13:57]
Yesterday I made decent progress on the engine itself, and the MUDSocket stuff. Today's focus is on user accounts, commands, and some basic commands.
***** [2020-08-14 Fri 18:38]
Wow. I actually have a MUD you can connect to and enter at least one command, =commands=, which tells you what commands you have.

It took so much tinkering to end up basically back where I started, but I'm a lot happier with the code.

The Org-mode file itself, that holds all the code, and the organization of the procedures across Racket files... is something I'm less pleased with. I'm going to give that some thought, while also thinking about what's next in terms of adding to the MUD.
**** 2020-08-16 Sunday
***** [2020-08-16 Sun 10:21]
      :PROPERTIES:
      :EXPORT_FILE_NAME: 2020-08-16-10-21
      :EXPORT_DATE: [2020-08-16 Sun 10:21]
      :END:
So, I've changed the name of the MUD engine, from /Racket-MUD/ to /qtMUD/.

qtMUD is the name I used for my Python MUD engine, and I really liked it but didn't want to reuse it for an engine in an entirely different language, especially when I wasn't sure if it'd work the same way. But, it does (more or less) and it's been a few years without anyone else touching the Python-language qtMUD, so I'm moving back to the name.

For the first MUD I'm building with qtMUD I decided to go with something relatively simple: players will spawn in a village in a forest, and will be able to =explore= the village and forest. Exploration results in acquiring resources like berries or branches, that can be =gifted= to the village. This'll influence the relationship between the village and player, potentially resulting in reciprocal gifts. Certain items like berries can be eaten to restore energy points, which'll be used to explore and move around th eworld.

This MUD will require the MUDSocket, Talker, and User Account components of the qtMUD library, and will prompt me to write a few others. The settlement and forest will be /areas/, which will each have a /description/, /surface area/, and one or more /exits/.

They'll also have /populations/ of plants and animals: the quantity of a population against the area's surface area will influence the likelihood of finding something.

The village will also have a quality of /gratitude/, which will track gift-givers and recipients, and it'll occasionally give gifts based on whats in its /inventory/: filled by players =gifting= things they collect.

#+begin_src txt
> look
Johara settlement, in Johara Forest. [10/10]
> explore
You explore the settlement and find three scraps of fabric. [8/10]
> explore --target=nails
You explore the settlement and don't find any nails. [6/10]
> explore --target=nails duration=1
You explore the settlement and find one nail. [5/10]
> inventory
You are holding: three scraps of fabric, one nail, and one sandwich.
> gift --recipient=here item=fabric quantity=3
You gift three fabric to the settlement. [4/10]
> eat sandwich
You eat the sandwich. [8/10]
> move forest
You move to western Johara Forest.
> explore
You run into a blackbear while exploring, and flee back to town, dropping everything.
> look
Johara settlement, in Johara Forest. [0/10]
#+end_src
**** 2020-08-18 Tuesday
***** [2020-08-18 Tue 18:34]
      :PROPERTIES:
      :EXPORT_FILE_NAME: 2020-08-18-18-34
      :EXPORT_DATE: [2020-08-18 Tue 18:34]
      :END:
      Oh gosh I've been bad about taking logs recently when I tinker on the MUD. In part because of how I've been tinkering: largely bouncing across the whole project. I've also been reorganizing a lot of how the project is laid out, so I have to keep focused until I'm done.

      I also haven't done any real consideration of how to track plans - or done anything to set up a git repository!

      In order to that, I need to clean up the Org-mode file which holds the project work. This leads me to wonder if there's any sort of cross-compatibility between Org-mode and Git, or... I'm not sure exactly what I'd make use of.
**** 2020-08-20 Thursday
***** [2020-08-20 Thu 10:07]
      :PROPERTIES:
      :EXPORT_DATE: [2020-08-20 Thu 10:07]
      :EXPORT_FILE_NAME: 2020-08-20-10-7
      :END:
      Ahhh heck. I think I need to change how Things work.

      So right now, for every quality, there's procedures like =set-thing-area-exits!=.

      This is really verbose, leads to lots of copy-pasting of code that might be nearly identical between qualities, except quality-name.

      So, maybe what I should do is have the basic set of thing-quality APIs check universes and things for these procedures, as keys inside hashtables, the way certain things like the MUDSocket check the =universe-procedures= for a custom login message, for example.

      This requires a new thing struct:

      #+begin_src racket
      (struct thing (name universe grammar qualities procedures))
      #+end_src

      And a new =make-thing= procedure, but we'll skip that for now to look at how the new =set-thing-quality!= might look:

      #+begin_src racket

	(define (set-thing-quality! changed-thing changed-quality new-value)
	  (let ([set-thing-quality!-procedure-key
		 (string->symbol
		  (join-list-of-strings-and-symbols-as-string
		   (list "set-thing-" changed-quality "!")))])
	    (cond [(thing-has-procedure? set-thing-quality!-procedure-key)
		   ((thing-procedure set-thing-quality!-procedure-key)
		    changed-thing new-value)]
		  [(and (thing-has-universe? changed-thing)
			(universe-has-procedure? (thing-universe changed-thing)
						 set-thing-quality!-procedure-key))
		   ((universe-procedure (thing-universe changed-thing)
					set-thing-quality!-procedure-key)
		    changed-thing new-value)]
		  [else
		   (hash-set! (thing-qualities changed-thing)
			      changed-quality new-value)])))
      #+end_src

      That's the idea anyway. This seems like a good choice of time to make use of the recently set-up git repository that this code rests in, to make a branch and tinker in it for a bit... after I take care of some real-world chores.
* Complete Files
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: programming/qtmud/files/
  :header-args: :mkdirp yes :noweb yes :padline yes
  :END:
** qtmud.rkt
#+name: qtmud.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/qtmud.rkt
  #lang racket

  (require racket/serialize)

  (require uuid)

  (provide (struct-out universe)
	   (struct-out thing)
	   deserialize-file
	   oxfordize-list
	   join-list-of-strings-and-symbols-as-symbol
	   make-universe
	   increment-universe-tick-count!
	   add-event-to-universe-schedule!
	   add-thing-to-universe-things!
           universe-has-procedure?
	   universe-procedure
	   set-universe-procedure!
	   thing-has-universe?
	   thing-has-quality?
	   thing-quality
	   set-thing-quality!
	   add-string-to-thing-quality!
	   thing-has-procedure?
	   thing-procedure
	   list-thing-names
           make-universe-logger
           run-universe-logger
	   make-universe
	   tick-universe
	   run-universe
	   create-thing)


  <<universe-struct>>
  <<thing-struct>>

  <<deserialize-file-procedure>>
  <<oxfordize-list-procedure>>
  <<join-list-of-strings-and-symbols-as-symbol-procedure>>

  <<increment-universe-tick-count!-procedure>>
  <<add-event-to-universe-schedule!-procedure>>
  <<add-thing-to-universe-things!-procedure>>
  <<universe-has-procedure?-procedure>>
  <<universe-procedure-procedure>>
  <<set-universe-procedure!-procedure>>

  <<thing-has-universe?-procedure>>
  <<thing-has-quality?-procedure>>
  <<thing-quality-procedure>>
  <<set-thing-quality!-procedure>>
  <<add-string-to-thing-quality!-procedure>>

  <<thing-has-procedure?-procedure>>
  <<thing-procedure-procedure>>

  <<list-thing-names-procedure>>

  <<make-universe-logger-procedure>>
  <<run-universe-logger-procedure>>

  <<make-universe-procedure>>
  <<tick-universe-procedure>>
  <<run-universe-procedure>>

  <<create-thing-procedure>>
#+end_src
** components/
*** mudsocket.rkt
#+name: mudsocket.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/mudsocket.rkt
  #lang racket

  (require uuid)

  (require "../qtmud.rkt")

  (provide make-mudsocket-tick-event-for-universe
	   make-mudsocket-parser-for-thing
	   make-mudsocket-sender-for-thing)


  <<make-mudsocket-tick-event-for-universe>>

  <<make-commands-mudsocket-command-for-thing-procedure>>
  <<make-help-mudsocket-command-for-thing-procedure>>
  <<make-who-mudsocket-command-for-thing-procedure>>

  <<make-mudsocket-parser-for-thing-procedure>>
  <<make-mudsocket-sender-for-thing-procedure>>
#+end_src
** muds
*** test-mud.rkt
#+name: test-mud.rkt
#+begin_src racket :tangle ./muds/test-mud.rkt
  #lang racket

  (require "../qtmud.rkt"
	   "../components/mudsocket.rkt")

  (define test-universe (make-universe "Testverse"))

  (run-universe-logger (make-universe-logger test-universe))

  (add-event-to-universe-schedule!
   (make-mudsocket-tick-event-for-universe test-universe)
   test-universe)

  (define test-mud (run-universe test-universe))
#+end_src
