#+title: qtMUD
#+hugo_base_dir: ~/hugo/emsenn-net
#+hugo_section: /programming/qtmud
#+header-args: :noweb yes
#+setupfile: https://fniessen.github.io/org-html-themes/setup/theme-bigblow.setup
#+todo: plan draft code document test | released
#+todo: - | cancelled
#+options: todo:t
#+macro: struct [[https://emsenn.net/programming/qtmud/structs/$1][$1]]
#+macro: procedure [[https://emsenn.net/programming/qtmud/procedures/$1][$1]]
*/qtMUD/* is a game engine for running a multi-user dimension, or /MUD/: traditionally text-interface online services, typically role-playing games.

It is in /super/-*/duper/* early development. Not only are there a tremendous amount of bugs, but the code that does work doesn't follow a unified style, has very little documentation, and is incredibly inefficient. /Sorry!/
* Bulletins
  :PROPERTIES:
  :EXPORT_HUGO_SECTION*: bulletins
  :EXPORT_HUGO_TYPE: bulletin
  :END:
** 2020
*** 2020-08 August
**** 2020-08-14 Friday
***** Overhaul wrapping up
      :PROPERTIES:
      :EXPORT_FILE_NAME: 2020-08-14-overhaul-wrapping-up
      :EXPORT_DATE: [2020-08-14 Fri 10:18]
      :END:
The latest overhaul of the code, where the relatively useless "handler" stuff was ripped out, is nearly complete.
**** 2020-08-16 Sunday
***** Name Change: Racket-MUD to qtMUD
      :PROPERTIES:
      :EXPORT_DATE: [2020-08-16 Sun 10:24]
      :EXPORT_FILE_NAME: 2020-08-16-name-change-racket-mud-to-qtmud
      :END:
I'm changing the name of the project to qtMUD, for the "/qualities/ of /things/ MUD," which is an accurate description of how the MUD works. And, it's a homonym with "cutie MUD" which is, well, cute.
* Documentation
  :PROPERTIES:
  :EXPORT_HUGO_SECTION*: documentation
  :END:
** qtMUD Overview
   :PROPERTIES:
   :EXPORT_FILE_NAME: qtmud-overview
   :END:
* Engine Code
  :PROPERTIES:
  :header-args: :noweb yes
  :EXPORT_FILE_NAME: engine
  :END:
#+toc: headlines 2 local
Like many MUDs that have come before it, qtMUD divides its code up into an engine (documented below) and a [[../library/][library]] of components. See the [[../documentation/qtmud-overview/][/qtMUD Overview/]] for an explanation of how these parts relate.

Explaining how the qtMUD engine works is best done by looking at its name: it's the "qt" MUD: that stands for /qualities of things/:

The things that exist within the MUD: player-characters, items, game areas, are all /things/, possessing different /qualities/.
** Thing
#+name: thing-struct
#+begin_src racket
    (struct thing
      (name universe
	    grammar
	    qualities)
      #:mutable)
#+end_src
*** Making a Thing
**** make-thing
     :PROPERTIES:
     :EXPORT_FILE_NAME: make-thing
     :EXPORT_HUGO_TYPE: qtprocedure
     :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure for making a new qtMUD thing."
     :END:
 The =make-thing= procedure is simply an interface for the =thing= struct, coming with some defaults for filling out the mud (=#f=), grammar, and qualities (empty hash-tables).
 #+name: make-thing-procedure
 #+caption: qtMUD's =make-thing= procedure: creates a new {{{struct(thing)}}}.
 #+begin_src racket :noweb no-export
   (define (make-thing [name "thing"] [chosen-universe #f] #:grammar [grammar #f] #:qualities [qualities #f])
     (log-info "Making a new thing named ~a~a"
		name
		(cond [chosen-universe (format " for ~a." (universe-name chosen-universe))]
		      [else "."]))
     (let ([made-thing
	    (thing
	     name
	     chosen-universe
	     (cond [grammar (make-hash grammar)][else (make-hash)])
	     (cond [qualities (make-hash qualities)][else (make-hash)]))])
       (when chosen-universe
	 (add-thing-to-universe-things! made-thing chosen-universe))
       made-thing))
 #+end_src
**** make-thing-maker-for-universe
 #+name: make-thing-maker-for-universe-procedure
 #+begin_src racket :noweb yes
   (define (make-thing-maker-for-universe making-universe)
   (λ (name #:grammar [grammar #f] #:qualities [qualities #f])
     (cond [(and grammar qualities)
            (make-thing name making-universe #:grammar grammar #:qualities qualities)]
	   [grammar
            (make-thing name making-universe #:grammar grammar)]
           [qualities
            (make-thing name making-universe #:qualities qualities)]
           [else
            (make-thing name making-universe)])))
 #+end_src
*** Working with a Thing
**** Qualities
***** thing-has-quality?
      :PROPERTIES:
      :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure for reading a quality from a qtMUD thing."
      :EXPORT_FILE_NAME: thing-has-quality?
      :EXPORT_HUGO_TYPE: racket-procedure
      :END:
  #+name: thing-has-quality?-procedure
  #+caption: qtMUD's =thing-quality= procedure: reads a {{{struct(thing)}}}'s quality.
  #+begin_src racket :noweb no-export
    (define (thing-has-quality? queried-thing quality)
      (log-debug "Checking if ~a has ~a quality." (thing-name queried-thing) quality)
      (let ([qualities (thing-qualities queried-thing)])
	(cond [(hash-has-key? qualities quality)
	       (hash-ref qualities quality)]
	      [else #f])))
  #+end_src
***** thing-quality
      :PROPERTIES:
      :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure for reading a quality from a qtMUD thing."
      :EXPORT_FILE_NAME: thing-quality
      :EXPORT_HUGO_TYPE: racket-procedure
      :END:
  #+name: thing-quality-procedure
  #+caption: qtMUD's =thing-quality= procedure: reads a {{{struct(thing)}}}'s quality.
  #+begin_src racket :noweb no-export
    (define (thing-quality queried-thing quality)
      (cond [(thing-has-quality? queried-thing quality)
             (log-debug "Reading ~a quality from ~a" quality (thing-name queried-thing))
	     (hash-ref (thing-qualities queried-thing) quality)]
	    [else
	     (log-warning "Tried to read non-existent ~a quality from ~a."
			  quality
			  (thing-name queried-thing))]))

  #+end_src
***** set-thing-quality!
      :PROPERTIES:
      :EXPORT_FILE_NAME: set-thing-quality!
      :EXPORT_HUGO_TAGS: "qtMUD"
      :EXPORT_HUGO_TYPE: procedure
      :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Racket procedure to set a qtMUD thing's quality to a new value."
      :END:
   #+name: set-thing-quality!-procedure
   #+caption: Racket procedure to set a qtMUD thing's quality to a new value.
   #+begin_src racket :noweb no-export
     (define (set-thing-quality! changed-thing changed-quality new-value)
       (log-debug "Setting ~a's ~a quality to ~a." (thing-name changed-thing) changed-quality new-value)
       (hash-set! (thing-qualities changed-thing) changed-quality new-value))
   #+end_src
*** Working with a group of Things
**** list-thing-names
     :PROPERTIES:
     :EXPORT_FILE_NAME: add-ecoregions-quality-to-thing
     :EXPORT_DATE: [2020-08-12 Wed 12:42]
     :EXPORT_HUGO_TAGS: "qtMUD"
     :EXPORT_HUGO_TYPE: procedure
     :END:
  #+name: list-thing-names-procedure
  #+caption: Add a thing to another's ecoregions.
  #+begin_src racket :noweb no-export
    (define (list-thing-names things)
      (oxfordize-list
       (map
	(λ (this-thing)
	  (thing-name this-thing))
	things)))
  #+end_src
** Universe
#+name: universe-struct
#+begin_src racket
  (struct universe
    (name
     tick-count schedule
     things procedures)
    #:mutable)
#+end_src
*** Making a Universe
#+name: make-universe-procedure
#+begin_src racket :noweb yes
(define (make-universe [name "qtVerse"] [events '()])
  (log-info "Making a new universe named ~a" name)
  (universe name 0 events (list) (make-hash)))
#+end_src
*** Working with a Universe
**** Tick Count
***** increment-universe-tick-count!
  #+name: increment-universe-tick-count!-procedure
  #+begin_src racket :noweb yes
  (define (increment-universe-tick-count! incremented-universe [addition 1])
    (set-universe-tick-count!
      incremented-universe (+ (universe-tick-count incremented-universe) addition)))
  #+end_src
**** Schedule
***** add-event-to-universe-schedule!
  #+name: add-event-to-universe-schedule!-procedure
  #+begin_src racket :noweb yes
    (define (add-event-to-universe-schedule! new-event changed-universe)
      (cond [(procedure? new-event)
	     (set-universe-schedule! changed-universe (append (universe-schedule changed-universe) (list new-event)))]
	    [else
	     (log-warning "Tried to schedule non-procedure as event: ~a" new-event)]))
  #+end_src
***** add-thing-to-universe-things!
  #+name: add-thing-to-universe-things!-procedure
  #+begin_src racket :noweb yes
    (define (add-thing-to-universe-things! new-thing changed-universe)
      (set-universe-things! changed-universe (append (universe-things changed-universe) (list new-thing))))
  #+end_src
**** Procedures
***** universe-has-procedure?
#+name: universe-has-procedure?-procedure
#+begin_src racket
(define (universe-has-procedure? queried-universe queried-procedure)
  (hash-has-key? (universe-procedures queried-universe) queried-procedure))
#+end_src
***** universe-procedure
#+name: universe-procedure-procedure
#+begin_src racket :noweb yes
  (define (universe-procedure queried-universe queried-procedure)
    (cond [(universe-has-procedure? queried-universe queried-procedure)
	   (hash-ref (universe-procedures queried-universe) queried-procedure)]
	  [else
	   (log-warning "Tried to use procedure ~a from universe ~a, but it doesn't exist."
			queried-procedure
			(universe-name queried-universe))]))
#+end_src
***** set-universe-procedure!
#+name: set-universe-procedure!-procedure
#+begin_src racket :noweb yes
  (define (set-universe-procedure! changed-universe new-procedure-key new-procedure)
    (hash-set!
     (universe-procedures
      changed-universe)
     new-procedure-key
     new-procedure))
#+end_src
*** Making a Universe Tick
**** tick-universe
 #+name: tick-universe-procedure
 #+begin_src racket :noweb yes
   (define (tick-universe ticked-universe)
     (increment-universe-tick-count! ticked-universe)
     (log-debug "Universe ~a is beginning its tick, count #~a" (universe-name ticked-universe) (universe-tick-count ticked-universe))
     (let ([events-this-tick (universe-schedule ticked-universe)])
       (log-debug "Universe ~a is ticking, looking at events: ~a" (universe-name ticked-universe) events-this-tick)
       (set-universe-schedule! ticked-universe '())
       (let loop ()
	 (unless (null? events-this-tick)
	   (let ([current-event (car events-this-tick)])
             (log-debug "Universe ~a is ticking, looking at event: ~a" (universe-name ticked-universe) current-event)
	     (set! events-this-tick (cdr events-this-tick))
	     (let ([event-result (current-event ticked-universe)])
	       (when (universe? event-result) (set! ticked-universe event-result))))
	   (loop))))
     (log-debug "Universe ~a has ended its tick, count #~a" (universe-name ticked-universe) (universe-tick-count ticked-universe))
     ticked-universe)
 #+end_src
**** run-universe
 #+name: run-universe-procedure
 #+begin_src racket :noweb yes
   (define (run-universe running-universe [tick-rate 200])
     (thread
      (λ () (let loop ()
	      (set! running-universe (tick-universe running-universe))
	      (sleep 0.2)
	      (loop)))))
 #+end_src
old:
 #+begin_src racket :noweb yes
   (define (run-universe running-universe [tick-rate 200])
     (define time-of-last-tick (current-inexact-milliseconds))
     (thread
      (λ ()
	(let loop ()
 ;	 (log-debug "CIM/tick difference is ~a"
 ;		    (- (current-inexact-milliseconds) time-of-last-tick))
	  (when (> (- (current-inexact-milliseconds) time-of-last-tick) tick-rate)
 ;	   (log-debug "Triggering tick of ~a" (universe-name running-universe))
            (set! running-universe (tick-universe running-universe))
	    (set! time-of-last-tick (current-inexact-milliseconds)))
	  (loop)))))
 #+end_src
** Utilities
**** oxfordize-list
 #+name: oxfordize-list-procedure
 #+begin_src racket :noweb yes
 (define (oxfordize-list strings)
   (cond
     [(null? strings)
      (log-warning "Tried to oxfordize an empty list.")]
     [(null? (cdr strings))
      (car strings)]
     [(null? (cddr strings))
      (string-join strings " and ")]
     [else
      (string-join strings ", "
                   #:before-first ""
                   #:before-last ", and ")]))
 #+end_src
**** deserialize-file
     :PROPERTIES:
     :EXPORT_FILE_NAME: deserialize-file
     :END:
 #+name: deserialize-file-procedure
 #+begin_src racket :noweb no-export
   (define (deserialize-file save-file)
     (when (file-exists? save-file)
       (log-debug "Deserializing file ~a" save-file)
       (with-handlers
	 ([exn:fail:filesystem:errno?
	   (λ (E) (log-warning "Failed to deserialize file: ~a" E))])
	 (with-input-from-file save-file (λ () (deserialize (read)))))))
 #+end_src
**** make-universe-logger
#+name: make-universe-logger-procedure
#+begin_src racket
  (define (make-universe-logger logging-universe [loglevel 'info])
    (define universe-log
      (make-logger (string->symbol (universe-name logging-universe))))
    (define universe-log-receiver
      (make-log-receiver universe-log loglevel))
    (cons universe-log universe-log-receiver))
#+end_src
**** run-universe-logger
#+name: run-universe-logger-procedure
#+begin_src racket
  (define (run-universe-logger universe-logger)
    (let ([universe-log (car universe-logger)]
	  [universe-log-receiver (cdr universe-logger)])
      (current-logger universe-log)
      (thread (λ ()
		(let log-loop ()
		  (define log-vector (sync universe-log-receiver))
		  (let ([log-level (vector-ref log-vector 0)]
			[log-string (substring
				     (vector-ref log-vector 1)
				     12
				     (length (string->list
					      (vector-ref log-vector 1))))])
		    (cond[ (eq? log-level 'debug)
			   (printf ">>> \"~a\"\n"
				   log-string)]
			  [else
			   (printf "\"~a\"\n" log-string)]))
		  (log-loop))))))
#+end_src

* Library Code
  :PROPERTIES:
  :header-args: :noweb yes
  :EXPORT_FILE_NAME: library
  :END:
#+toc: headlines 1 local
** plan Animation
*** Qualities of Animation
**** actions
**** thing-actions
**** add-actions-to-thing
**** set-thing-actions!
**** thing-has-actions?
**** thing-action
**** add-action-to-thing
**** thing-has-action?
**** metabolism
**** thing-metabolism
**** add-metabolism-to-thing!
**** set-thing-metabolism!
**** thing-has-metabolism?
**** make-small-mall-metabolism-for-thing
*** Basic Actions
**** movement
**** looking
**** make-thing-look-at-thing
#+name: make-thing-look-at-thing-procedure
#+begin_src racket
  (define (make-thing-look-at-thing looking-thing looked-thing)
  (format "~a" (thing-name looked-thing)))
#+end_src
*** MUDSocket Commands
***** look
#+name: make-look-mudsocket-command-for-thing-procedure
#+begin_src racket :noweb yes
    (define (make-look-mudsocket-command-for-thing commanding-thing)
      (λ (command-arguments)
	(cond [(hash-empty? command-arguments)
	       (cond [(thing-has-parent-container? commanding-thing)
		      (let ([commanding-thing-parent-container
			     (thing-parent-container commanding-thing)])
			(add-string-to-thing-mudsocket-output-buffer!
			 (format "[    ~a    ]~a~a"
				 (thing-name commanding-thing-parent-container)
				 (cond [(thing-has-area-description?
					 commanding-thing-parent-container)
					(format "\n  ~a"
						(thing-area-description
						 commanding-thing-parent-container))]
				       [else ""])
				 (cond [(thing-has-area-exits?
					 commanding-thing-parent-container)
					(format "\n  Area exits: ~a"
						(oxfordize-list
						 (hash-keys
						  (thing-area-exits
						   commanding-thing-parent-container))))]
				       [else ""]))
			 commanding-thing))]
		     [else
		      (add-string-to-thing-mudsocket-output-buffer!
		       "You look around, but you aren't anyplace."
		       commanding-thing)])]
	      [(hash-has-key? command-arguments "container")
	       (add-string-to-thing-mudsocket-output-buffer!
		"Looking inside things doesn't work yet, sorry."
		commanding-thing)]
	      [(hash-has-key? command-arguments 'line)
	       (add-string-to-thing-mudsocket-output-buffer!
		"Looking at things doesn't work yet, sorry."
		commanding-thing)])))
#+end_src
***** move
#+name: make-move-mudsocket-command-for-thing-procedure
#+begin_src racket :noweb yes
    (define (make-move-mudsocket-command-for-thing commanding-thing)
      (λ (command-arguments)
	(let* ([commanding-thing-parent-container (thing-parent-container commanding-thing)]
	       [commanding-thing-parent-container-area-exits
		(thing-area-exits commanding-thing-parent-container)])
	  (cond [(hash-has-key? command-arguments 'line)
		 (cond [(hash-has-key? commanding-thing-parent-container-area-exits
				       (hash-ref command-arguments 'line))
			(add-string-to-thing-mudsocket-output-buffer!
			 (format "You attempt to move ~a."
				 (hash-ref command-arguments 'line))
			 commanding-thing)
			(add-thing-to-thing-contents!
			 commanding-thing
			 (hash-ref commanding-thing-parent-container-area-exits
				   (hash-ref command-arguments 'line)))]
		       [else
			(add-string-to-thing-mudsocket-output-buffer!
			 "Invalid exit."
			 commanding-thing)])]
		[else
		 (add-string-to-thing-mudsocket-output-buffer!
		  "You must use this command with an exit, try \"look\"."
		  commanding-thing)]))))
#+end_src

** plan Areas
*** Map
#+name: make-map-from-areas-procedure
#+begin_src racket
(define (make-map-from-areas areas)
 (make-hash areas))
#+end_src
*** Description
**** thing-area-description
#+name: thing-area-description-procedure
#+begin_src racket :noweb yes
  (define (thing-area-description queried-thing)
    (thing-quality queried-thing 'area-description))
#+end_src
**** thing-has-area-description?
#+name: thing-has-area-description?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-area-description? queried-thing)
    (thing-has-quality? queried-thing 'area-description))
#+end_src
**** set-thing-area-description!
#+name: set-thing-area-description!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-area-description! changed-thing new-area-description)
    (log-info "Setting ~a Area-Description to ~a"
	      (thing-name changed-thing)
	      new-area-description)
    (cond [(thing-has-area-description? changed-thing)
	   (set-thing-quality! changed-thing 'area-description new-area-description)]
	  [else
	   (add-area-description-to-thing! changed-thing new-area-description)]))
#+end_src
**** add-area-description-to-thing!
#+name: add-area-description-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-area-description-to-thing! changed-thing new-area-description)
    (unless (thing-has-area-description? changed-thing)
      (log-debug "Adding Area-Description quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'area-description (void))
      (set-thing-area-description! changed-thing new-area-description)))
#+end_src
*** Exits
**** thing-area-exits
#+name: thing-area-exits-procedure
#+begin_src racket :noweb yes
  (define (thing-area-exits queried-thing)
    (thing-quality queried-thing 'area-exits))
#+end_src
**** thing-has-area-exits?
#+name: thing-has-area-exits?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-area-exits? queried-thing)
    (thing-has-quality? queried-thing 'area-exits))
#+end_src
**** set-thing-area-exits!
#+name: set-thing-area-exits!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-area-exits! changed-thing new-area-exits)
    (log-info "Setting ~a Area-Exits to ~a"
	      (thing-name changed-thing)
	      new-area-exits)
    (cond [(thing-has-area-exits? changed-thing)
	   (set-thing-quality! changed-thing 'area-exits (make-hash new-area-exits))]
	  [else
	   (add-area-exits-to-thing! changed-thing new-area-exits)]))
#+end_src
**** add-area-exits-to-thing!
#+name: add-area-exits-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-area-exits-to-thing! changed-thing new-area-exits)
    (unless (thing-has-area-exits? changed-thing)
      (log-debug "Adding Area-Exits quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'area-exits (void))
      (set-thing-area-exits! changed-thing new-area-exits)))
#+end_src
*** Populations
*** Facilities
*** Other Stuff?
** Containers
**** thing-contents
#+name: thing-contents-procedure
#+begin_src racket :noweb yes
  (define (thing-contents queried-thing)
    (thing-quality queried-thing 'contents))
#+end_src
**** thing-has-contents?
#+name: thing-has-contents?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-contents? queried-thing)
    (thing-has-quality? queried-thing 'contents))
#+end_src
**** set-thing-contents!
#+name: set-thing-contents!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-contents! changed-thing new-contents)
    (log-info "Setting ~a Contents to ~a"
	      (thing-name changed-thing)
	      new-contents)
    (cond [(thing-has-contents? changed-thing)
	   (set-thing-quality! changed-thing 'contents new-contents)]
	  [else
	   (add-contents-to-thing! changed-thing new-contents)]))
#+end_src
**** add-contents-to-thing!
#+name: add-contents-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-contents-to-thing! changed-thing [new-contents (list)])
    (unless (thing-has-contents? changed-thing)
      (log-debug "Adding Contents quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'contents (list))
      (set-thing-contents! changed-thing new-contents)))
#+end_src
**** add-thing-to-thing-contents!
#+name: add-thing-to-thing-contents!-procedure
#+begin_src racket
  (define (add-thing-to-thing-contents! added-thing container-thing)
    (when (thing-has-parent-container? added-thing)
      (let ([added-thing-parent-container (thing-parent-container added-thing)])
	(when (thing? added-thing-parent-container)
	  (remove-thing-from-thing-contents! added-thing added-thing-parent-container))))
    (set-thing-parent-container! added-thing container-thing)
    (cond [(thing-has-contents? container-thing)
           (set-thing-contents! container-thing
                                (append (thing-contents container-thing)
                                        (list added-thing)))]
          [else
           (add-contents-to-thing! container-thing (list added-thing))]))
#+end_src
**** remove-thing-from-thing-contents!
#+name: remove-thing-from-thing-contents!-procedure
#+begin_src racket
  (define (remove-thing-from-thing-contents! removed-thing container-thing)
    (when
	(and (thing-has-parent-container? removed-thing)
	     (eq? (thing-parent-container removed-thing) container-thing))
      (set-thing-parent-container! removed-thing (void)))
    (set-thing-contents!
     container-thing
     (remove removed-thing (thing-contents container-thing))))
#+end_src
**** thing-parent-container
#+name: thing-parent-container-procedure
#+begin_src racket :noweb yes
  (define (thing-parent-container queried-thing)
    (thing-quality queried-thing 'parent-container))
#+end_src
**** thing-has-parent-container?
#+name: thing-has-parent-container?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-parent-container? queried-thing)
    (thing-has-quality? queried-thing 'parent-container))
#+end_src
**** set-thing-parent-container!
#+name: set-thing-parent-container!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-parent-container! changed-thing new-parent-container)
    (log-info "Setting ~a Container to ~a"
	      (thing-name changed-thing)
	      new-parent-container)
    (cond [(thing-has-parent-container? changed-thing)
	   (set-thing-quality! changed-thing 'parent-container new-parent-container)]
	  [else
	   (add-parent-container-to-thing! changed-thing new-parent-container)]))
#+end_src
**** add-parent-container-to-thing!
#+name: add-parent-container-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-parent-container-to-thing! changed-thing [new-parent-container (void)])
    (unless (thing-has-parent-container? changed-thing)
      (log-debug "Adding Container quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'parent-container (void))
      (set-thing-parent-container! changed-thing new-parent-container)))
#+end_src
** document MUDSocket
   :PROPERTIES:
   :EXPORT_FILE_NAME: mudsocket
   :END:
*** make-mudsocket-tick-event-for-universe
#+name: make-mudsocket-tick-event-for-universe
#+begin_src racket :noweb yes
  (define (make-mudsocket-tick-event-for-universe this-universe [port 4242])
    (log-debug "Making a MUDSocket tick event.")
    (define mudsocket-listener (tcp-listen port 5 #t))
    (define current-connections '())
    (define (tick-mudsocket-event ticked-universe)
      (define (accept-new-connection)
	(define-values (mudsocket-in mudsocket-out)
	  (tcp-accept mudsocket-listener))
	(define-values (local-ip local-port remote-ip remote-port)
	  (tcp-addresses mudsocket-in #t))
	(log-info "MUDSocket accepted a new connection from ~a:~a"
		  remote-ip remote-port)
	(define connected-thing
	  (make-thing "MUDSocket client" ticked-universe))
	(add-mudsocket-in-to-thing! connected-thing mudsocket-in)
	(add-mudsocket-out-to-thing! connected-thing mudsocket-out)
	(add-mudsocket-ip-to-thing! connected-thing remote-ip)
	(add-mudsocket-port-to-thing! connected-thing remote-port)
        (add-mudsocket-output-buffer-to-thing! connected-thing)
	(add-mudsocket-sender-to-thing! connected-thing)
	(add-mudsocket-parser-to-thing! connected-thing
          (make-mudsocket-login-parser-for-thing connected-thing))
	(add-talker-channels-to-thing! connected-thing)
	(add-mudsocket-commands-to-thing! connected-thing)
	(set! current-connections (append (list connected-thing) current-connections))
	(add-thing-to-universe-things! connected-thing this-universe)
	(cond [(universe-has-procedure? this-universe 'handle-mudsocket-connection)
	       ((universe-procedure this-universe 'handle-mudsocket-connection)
		connected-thing)]
	      [else
	       (add-string-to-thing-mudsocket-output-buffer!
		(format "Your connection to ~a has been accepted."
			(universe-name ticked-universe))
                connected-thing)]))
      (map
       (λ (connected-thing)
	 (let ([connected-thing-name (thing-name connected-thing)]
	       [connected-thing-mudsocket-in (thing-mudsocket-in connected-thing)]
	       [connected-thing-mudsocket-out (thing-mudsocket-out connected-thing)]
	       [connected-thing-mudsocket-ip (thing-mudsocket-ip connected-thing)]
	       [connected-thing-mudsocket-port (thing-mudsocket-port connected-thing)]
	       [connected-thing-mudsocket-output-buffer (thing-mudsocket-output-buffer connected-thing)]
	       [connected-thing-mudsocket-parser (thing-mudsocket-parser connected-thing)]
	       [connected-thing-mudsocket-sender (thing-mudsocket-sender connected-thing)])
	   (define (disconnect)
	     (close-input-port connected-thing-mudsocket-in)
	     (close-output-port connected-thing-mudsocket-out)
	     (set! current-connections (remove connected-thing current-connections))
	     (log-info "MUDSocket disconnected connection from ~a:~a"
		       connected-thing-mudsocket-ip
		       connected-thing-mudsocket-port))
	   ; todo: add ^-- (destroy-thing connected-thing) above
	   (cond
	     [(port-closed? connected-thing-mudsocket-in)
	      (disconnect)]
	     [(byte-ready? connected-thing-mudsocket-in)
	      (with-handlers
		  ([exn:fail:read?
		    (λ (e) (log-warning "MUDSocket encountered issue with ~a: ~a"
					connected-thing-name
					e))]
		 [exn:fail:network:errno?
		  (λ (e) (log-warning "MUDSocket encountered issue with ~a: ~a"
				      connected-thing-name
				      e))])
		(let ([connected-thing-line-in (read-line connected-thing-mudsocket-in)])
		  (cond [(string? connected-thing-line-in)
			 (connected-thing-mudsocket-parser (string-trim connected-thing-line-in))]
			[(eof-object? connected-thing-line-in)
			 (disconnect)])))])
		(when (> (string-length connected-thing-mudsocket-output-buffer) 0)
		  (connected-thing-mudsocket-sender))))
       current-connections)
      (when (tcp-accept-ready? mudsocket-listener)
	(accept-new-connection))
      (add-event-to-universe-schedule! tick-mudsocket-event ticked-universe))
    (set-universe-procedure! this-universe 'list-mudsocket-current-connections
     (λ () current-connections))
    tick-mudsocket-event)


#+end_src
*** mudsocket-in
**** thing-mudsocket-in
#+name: thing-mudsocket-in-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-in queried-thing)
    (thing-quality queried-thing 'mudsocket-in))
#+end_src
**** thing-has-mudsocket-in?
#+name: thing-has-mudsocket-in?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-in? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-in))
#+end_src
**** set-thing-mudsocket-in!
#+name: set-thing-mudsocket-in!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-in! changed-thing new-mudsocket-in)
    (log-info "Setting ~a MUDSocket-In to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-in)
    (cond [(thing-has-mudsocket-in? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-in new-mudsocket-in)]
	  [else
	   (add-mudsocket-in-to-thing! changed-thing new-mudsocket-in)]))
#+end_src
**** add-mudsocket-in-to-thing!
#+name: add-mudsocket-in-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-in-to-thing! changed-thing new-mudsocket-in)
    (unless (thing-has-mudsocket-in? changed-thing)
      (log-debug "Adding MUDSocket-In quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-in (void))
      (set-thing-mudsocket-in! changed-thing new-mudsocket-in)))
#+end_src
*** mudsocket-input-buffer
**** thing-mudsocket-input-buffer
#+name: thing-mudsocket-input-buffer-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-input-buffer queried-thing)
    (thing-quality queried-thing 'mudsocket-input-buffer))
#+end_src
**** thing-has-mudsocket-input-buffer?
#+name: thing-has-mudsocket-input-buffer?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-input-buffer? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-input-buffer))
#+end_src
**** set-thing-mudsocket-input-buffer!
#+name: set-thing-mudsocket-input-buffer!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-input-buffer! changed-thing new-mudsocket-input-buffer)
    (log-info "Setting ~a MUDSocket-input-buffer to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-input-buffer)
    (cond [(thing-has-mudsocket-input-buffer? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-input-buffer new-mudsocket-input-buffer)]
	  [else
	   (add-mudsocket-input-buffer-to-thing! changed-thing new-mudsocket-input-buffer)]))
#+end_src
**** add-mudsocket-input-buffer-to-thing!
#+name: add-mudsocket-input-buffer-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-input-buffer-to-thing! changed-thing [new-mudsocket-input-buffer ""])
    (unless (thing-has-mudsocket-input-buffer? changed-thing)
      (log-debug "Adding MUDSocket-input-buffer quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-input-buffer (void))
      (set-thing-mudsocket-input-buffer! changed-thing new-mudsocket-input-buffer)))
#+end_src
*** mudsocket-ip
**** thing-mudsocket-ip
#+name: thing-mudsocket-ip-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-ip queried-thing)
    (thing-quality queried-thing 'mudsocket-ip))
#+end_src
**** thing-has-mudsocket-ip?
#+name: thing-has-mudsocket-ip?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-ip? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-ip))
#+end_src
**** set-thing-mudsocket-ip!
#+name: set-thing-mudsocket-ip!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-ip! changed-thing new-mudsocket-ip)
    (log-info "Setting ~a Mudsocket-Ip to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-ip)
    (cond [(thing-has-mudsocket-ip? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-ip new-mudsocket-ip)]
	  [else
	   (add-mudsocket-ip-to-thing! changed-thing new-mudsocket-ip)]))
#+end_src
**** add-mudsocket-ip-to-thing!
#+name: add-mudsocket-ip-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-ip-to-thing! changed-thing new-mudsocket-ip)
    (unless (thing-has-mudsocket-ip? changed-thing)
      (log-debug "Adding Mudsocket-Ip quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-ip (void))
      (set-thing-mudsocket-ip! changed-thing new-mudsocket-ip)))
#+end_src

*** mudsocket-out
**** thing-mudsocket-out
#+name: thing-mudsocket-out-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-out queried-thing)
    (thing-quality queried-thing 'mudsocket-out))
#+end_src
**** thing-has-mudsocket-out?
#+name: thing-has-mudsocket-out?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-out? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-out))
#+end_src
**** set-thing-mudsocket-out!
#+name: set-thing-mudsocket-out!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-out! changed-thing new-mudsocket-out)
    (log-info "Setting ~a Mudsocket-Out to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-out)
    (cond [(thing-has-mudsocket-out? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-out new-mudsocket-out)]
	  [else
	   (add-mudsocket-out-to-thing! changed-thing new-mudsocket-out)]))
#+end_src
**** add-mudsocket-out-to-thing!
#+name: add-mudsocket-out-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-out-to-thing! changed-thing new-mudsocket-out)
    (unless (thing-has-mudsocket-out? changed-thing)
      (log-debug "Adding Mudsocket-Out quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-out (void))
      (set-thing-mudsocket-out! changed-thing new-mudsocket-out)))
#+end_src

*** mudsocket-output-buffer
**** thing-mudsocket-output-buffer
#+name: thing-mudsocket-output-buffer-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-output-buffer queried-thing)
    (thing-quality queried-thing 'mudsocket-output-buffer))
#+end_src
**** thing-has-mudsocket-output-buffer?
#+name: thing-has-mudsocket-output-buffer?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-output-buffer? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-output-buffer))
#+end_src
**** set-thing-mudsocket-output-buffer!
#+name: set-thing-mudsocket-output-buffer!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-output-buffer! changed-thing new-mudsocket-output-buffer)
    (log-info "Setting ~a Mudsocket-Output-Buffer to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-output-buffer)
    (cond [(thing-has-mudsocket-output-buffer? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-output-buffer new-mudsocket-output-buffer)]
	  [else
	   (add-mudsocket-output-buffer-to-thing! changed-thing new-mudsocket-output-buffer)]))
#+end_src
**** add-mudsocket-output-buffer-to-thing!
#+name: add-mudsocket-output-buffer-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-output-buffer-to-thing! changed-thing [new-mudsocket-output-buffer ""])
    (unless (thing-has-mudsocket-output-buffer? changed-thing)
      (log-debug "Adding Mudsocket-Output-Buffer quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-output-buffer (void))
      (set-thing-mudsocket-output-buffer! changed-thing new-mudsocket-output-buffer)))
#+end_src
**** clear-thing-mudsocket-output-buffer!
#+name: clear-thing-mudsocket-output-buffer!-procedure
#+begin_src racket :noweb yes
  (define (clear-thing-mudsocket-output-buffer! changed-thing)
    (log-debug "Clearing the MUDSocket-OutputBuffer of ~a"
	       (thing-name changed-thing))
    (set-thing-mudsocket-output-buffer! changed-thing ""))
#+end_src
**** add-string-to-thing-mudsocket-output-buffer!
#+name: add-string-to-thing-mudsocket-output-buffer!-procedure
#+begin_src racket :noweb yes
(define (add-string-to-thing-mudsocket-output-buffer! new-string changed-thing)
  (set-thing-mudsocket-output-buffer! changed-thing (string-append (thing-mudsocket-output-buffer changed-thing) new-string)))
#+end_src
*** mudsocket-parser
**** thing-mudsocket-parser
#+name: thing-mudsocket-parser-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-parser queried-thing)
    (thing-quality queried-thing 'mudsocket-parser))
#+end_src
**** thing-has-mudsocket-parser?
#+name: thing-has-mudsocket-parser?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-parser? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-parser))
#+end_src
**** set-thing-mudsocket-parser!
#+name: set-thing-mudsocket-parser!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-parser! changed-thing new-mudsocket-parser)
    (log-info "Setting ~a Mudsocket-Parser to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-parser)
    (cond [(thing-has-mudsocket-parser? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-parser new-mudsocket-parser)]
	  [else
	   (add-mudsocket-parser-to-thing! changed-thing new-mudsocket-parser)]))
#+end_src
**** add-mudsocket-parser-to-thing!
#+name: add-mudsocket-parser-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-parser-to-thing! changed-thing [new-mudsocket-parser #f])
    (unless (thing-has-mudsocket-parser? changed-thing)
      (log-debug "Adding Mudsocket-Parser quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-parser (void))
      (unless new-mudsocket-parser
        (set! new-mudsocket-parser (make-mudsocket-parser-for-thing changed-thing)))
      (set-thing-mudsocket-parser! changed-thing new-mudsocket-parser)))
#+end_src

**** make-mudsocket-parser-for-thing
#+name: make-mudsocket-parser-for-thing-procedure
#+begin_src racket :noweb no-export
  (define (make-mudsocket-parser-for-thing parsing-thing)
    (define (parse-args args)
      (let ([results (make-hash)])
	(map
	 (λ (arg)
	   (cond [(and (> (string-length arg) 2)
		       (string=? (substring arg 0 2) "--"))
		  (let* ([split-arg (string-split arg "=")]
			 [arg-key (substring (car split-arg) 2)]
			 [arg-value (cdr split-arg)])
		    (hash-set! results arg-key arg-value))]
		 [(string=? (substring arg 0 1) "-")
		  (map
		   (λ (char)
		     (hash-set! results char #t)))]
		 [else (hash-set! results 'line (cond [(hash-has-key? results 'line)
						       (append (hash-ref results 'line)
							       (list arg))]
						      [else (list arg)]))]))
	 args)
	(when (hash-has-key? results 'line)
	  (hash-set! results 'line (string-join (hash-ref results 'line))))
	results))
    (λ (input-line)
      (let ([response ""]
	    [commands (thing-mudsocket-commands parsing-thing)])
	(log-debug "Parsing a line from ~a:\n  ~a" (thing-name parsing-thing) input-line)
	(when (> (string-length input-line) 0)
	  (let* ([split-input-line (string-split input-line)]
		 [first-word (car split-input-line)]
		 [parsed-args (parse-args (cdr split-input-line))])
	    (cond [(hash-has-key? commands first-word)
		   ((hash-ref commands first-word) parsed-args)]
		  [(member first-word (thing-talker-channels parsing-thing))
		   (when (hash-has-key? parsed-args 'line)
		     ((universe-procedure (thing-universe parsing-thing) 'broadcast)
		      (hash-ref parsed-args 'line)))]
		  [else (set! response "Invalid command.")]))
	  (when (> (string-length response) 0)
	    (add-string-to-thing-mudsocket-output-buffer! response parsing-thing))))))
#+end_src
**** make-mudsocket-login-parser-for-thing
#+name: make-mudsocket-login-parser-for-thing-procedure
#+begin_src racket :noweb no-export
  (define (make-mudsocket-login-parser-for-thing parsing-thing)
    (define login-stage 0)
    (λ (input-line)
      (log-debug "Received the following login line from ~a:\n  ~a"
		 (thing-name parsing-thing)
		 input-line)
      (let ([response ""])
	(cond [(= login-stage 0)
	       (set-thing-user-name!
		parsing-thing input-line)
	       (set-thing-name!
		parsing-thing input-line)
	       (cond [((universe-procedure
			(thing-universe parsing-thing) 'user-account?)
		       input-line)
		      (set! response
			    (format "An account exists for ~a. If it's yours, enter the password and press ENTER. Otherwise, disconnect [and reconnect]."
				    input-line))
		      (set! login-stage 1)]
		     [else (let ([new-password (substring (uuid-string) 0 8)])
			     (set-thing-user-password!
			      parsing-thing new-password)
			     ((universe-procedure
				(thing-universe parsing-thing) 'register-user-account!)
			      parsing-thing)
			     (set! response (format "There was no account namd ~a, so one was created. Your new password is\n\n~a\n\nPress ENTER when you're ready to log in."
						    input-line
						    new-password)))
			   (set! login-stage 9)])]
	      [(= login-stage 1)
	       (cond [((universe-procedure (thing-universe parsing-thing)
					   'check-user-account-password?)
		       (thing-name parsing-thing) input-line)
		      (set! response "Correct. Press ENTER to complete login.")
		      (set! login-stage 9)]
		     [else (set! response "Incorrect. Type your [desired] user-name and press ENTER.") (set! login-stage 0)])]
	      [(= login-stage 9)
	       (set-thing-mudsocket-parser! parsing-thing (make-mudsocket-parser-for-thing parsing-thing))
	       (cond
		   [(universe-has-procedure?
		     (thing-universe parsing-thing)
		     'handle-mudsocket-login)
		    ((universe-procedure
		      (thing-universe parsing-thing)
		      'handle-mudsocket-login)
		     parsing-thing)]
		   [else
		    (set! response "You've been logged in. You may chat with the \"cq\" command.")])])
	(when (> (string-length response) 0)
	  (set-thing-mudsocket-output-buffer! parsing-thing response)))))
#+end_src
*** mudsocket-port
**** thing-mudsocket-port
#+name: thing-mudsocket-port-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-port queried-thing)
    (thing-quality queried-thing 'mudsocket-port))
#+end_src
**** thing-has-mudsocket-port?
#+name: thing-has-mudsocket-port?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-port? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-port))
#+end_src
**** set-thing-mudsocket-port!
#+name: set-thing-mudsocket-port!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-port! changed-thing new-mudsocket-port)
    (log-info "Setting ~a Mudsocket-Port to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-port)
    (cond [(thing-has-mudsocket-port? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-port new-mudsocket-port)]
	  [else
	   (add-mudsocket-port-to-thing! changed-thing new-mudsocket-port)]))
#+end_src
**** add-mudsocket-port-to-thing!
#+name: add-mudsocket-port-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-mudsocket-port-to-thing! changed-thing new-mudsocket-port)
    (unless (thing-has-mudsocket-port? changed-thing)
      (log-debug "Adding Mudsocket-Port quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'mudsocket-port (void))
      (set-thing-mudsocket-port! changed-thing new-mudsocket-port)))
#+end_src
*** mudsocket-sender
**** thing-mudsocket-sender
#+name: thing-mudsocket-sender-procedure
#+begin_src racket :noweb yes
  (define (thing-mudsocket-sender queried-thing)
    (thing-quality queried-thing 'mudsocket-sender))
#+end_src
**** thing-has-mudsocket-sender?
#+name: thing-has-mudsocket-sender?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-mudsocket-sender? queried-thing)
    (thing-has-quality? queried-thing 'mudsocket-sender))
#+end_src
**** set-thing-mudsocket-sender!
#+name: set-thing-mudsocket-sender!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-mudsocket-sender! changed-thing new-mudsocket-sender)
    (log-info "Setting ~a Mudsocket-Sender to ~a"
	      (thing-name changed-thing)
	      new-mudsocket-sender)
    (cond [(thing-has-mudsocket-sender? changed-thing)
	   (set-thing-quality! changed-thing 'mudsocket-sender new-mudsocket-sender)]
	  [else
	   (add-mudsocket-sender-to-thing! changed-thing new-mudsocket-sender)]))
#+end_src
**** add-mudsocket-sender-to-thing!
#+name: add-mudsocket-sender-to-thing!-procedure
#+begin_src racket :noweb yes
    (define (add-mudsocket-sender-to-thing! changed-thing [new-mudsocket-sender #f])
      (unless (thing-has-mudsocket-sender? changed-thing)
	(log-debug "Adding Mudsocket-Sender quality to ~a"
		   (thing-name changed-thing))
	(set-thing-quality!
	 changed-thing
	 'mudsocket-sender (void))
	(set-thing-mudsocket-sender!
	 changed-thing
	 (cond [new-mudsocket-sender new-mudsocket-sender][else (make-mudsocket-sender-for-thing changed-thing)]))))

#+end_src
**** make-mudsocket-sender-for-thing
#+name: make-mudsocket-sender-for-thing-procedure
#+begin_src racket :noweb yes
  (define (make-mudsocket-sender-for-thing receiving-thing)
    (λ ()
      (let ([receiving-thing-name (thing-name receiving-thing)]
	    [receiving-thing-mudsocket-out (thing-mudsocket-out receiving-thing)]
	    [text-to-send (thing-mudsocket-output-buffer receiving-thing)])
	(log-debug "Sending ~a a message:\n  ~a"
		   receiving-thing-name
		   text-to-send)
	(with-handlers
	    ([exn?
	      (λ (e)
		(log-warning "Issue sending message to ~a: ~a"
			     receiving-thing-name
			     e))])
	  (display
	   (format
	    (cond
	      [(eq? #\newline
		    (last (string->list text-to-send)))
	       "~a"]
	      [else "~a\n"])
	    text-to-send)
	   receiving-thing-mudsocket-out)
	  (flush-output receiving-thing-mudsocket-out)
	  (clear-thing-mudsocket-output-buffer! receiving-thing)))))
#+end_src
*** MUDSocket Commands
**** Working with the MUDSocket commands quality
***** thing-mudsocket-commands
 #+name: thing-mudsocket-commands-procedure
 #+begin_src racket :noweb yes
   (define (thing-mudsocket-commands queried-thing)
     (thing-quality queried-thing 'mudsocket-commands))
 #+end_src
***** thing-has-mudsocket-commands?
 #+name: thing-has-mudsocket-commands?-procedure
 #+begin_src racket :noweb yes
   (define (thing-has-mudsocket-commands? queried-thing)
     (thing-has-quality? queried-thing 'mudsocket-commands))
 #+end_src
***** set-thing-mudsocket-commands!
 #+name: set-thing-mudsocket-commands!-procedure
 #+begin_src racket :noweb yes
   (define (set-thing-mudsocket-commands! changed-thing new-mudsocket-commands)
     (log-info "Setting ~a Mudsocket-Commands to ~a"
	       (thing-name changed-thing)
	       new-mudsocket-commands)
     (cond [(thing-has-mudsocket-commands? changed-thing)
	    (set-thing-quality! changed-thing 'mudsocket-commands new-mudsocket-commands)]
	   [else
	    (add-mudsocket-commands-to-thing! changed-thing new-mudsocket-commands)]))
 #+end_src
***** add-mudsocket-commands-to-thing!
 #+name: add-mudsocket-commands-to-thing!-procedure
 #+begin_src racket :noweb yes
   (define (add-mudsocket-commands-to-thing! changed-thing [new-mudsocket-commands #f])
     (unless
	 (thing-has-mudsocket-commands?
	  changed-thing)
       (log-debug "Adding MUDSocket-commands quality to ~a"
		  (thing-name
		   changed-thing))
       (set-thing-quality!
	changed-thing
	'mudsocket-commands
	(void))
       (set-thing-mudsocket-commands!
	changed-thing
	(cond [new-mudsocket-commands
	       new-mudsocket-commands]
	      [else
	       (make-hash
		(list
		 (cons "commands" (make-commands-mudsocket-command-for-thing changed-thing))
		 (cons "help" (make-help-mudsocket-command-for-thing changed-thing))
                 (cons "who" (make-who-mudsocket-command-for-thing changed-thing))))]))))
 #+end_src
***** add-new-mudsocket-commands-to-thing!
 #+name: add-new-mudsocket-commands-to-thing!-procedure
 #+begin_src racket :noweb yes
   (define (add-new-mudsocket-commands-to-thing! new-mudsocket-commands changed-thing)
     (unless (thing-has-mudsocket-commands? changed-thing)
       (add-mudsocket-commands-to-thing! changed-thing new-mudsocket-commands))
     (map
      (λ (new-mudsocket-command)
	(add-mudsocket-command-to-thing!
	 (car new-mudsocket-command)
	    (cdr new-mudsocket-command)
	    changed-thing))
      new-mudsocket-commands))
#+end_src
#+name: add-mudsocket-command-to-thing!-procedure
#+begin_src racket
   (define (add-mudsocket-command-to-thing!
	    new-mudsocket-command-key
	    new-mudsocket-command-procedure
	    changed-thing)
     (cond [(thing-has-mudsocket-commands? changed-thing)
	    (hash-set! (thing-mudsocket-commands changed-thing)
		       new-mudsocket-command-key
		       new-mudsocket-command-procedure)]
	   [else
	    (add-mudsocket-commands-to-thing!
	     changed-thing
	     (list (cons new-mudsocket-command-key
			 new-mudsocket-command-procedure)))]))

 #+end_src
**** Standard MUDSocket Commands
***** commands
 #+name: make-commands-mudsocket-command-for-thing-procedure
 #+begin_src racket :noweb yes
   (define (make-commands-mudsocket-command-for-thing
	    commanding-thing)
     (λ (args)
       (add-string-to-thing-mudsocket-output-buffer!
        (format
        "You have access to the following commands: ~a"
	(oxfordize-list (hash-keys (thing-mudsocket-commands commanding-thing))))
	commanding-thing)))
 #+end_src
***** help
#+name: make-help-mudsocket-command-for-thing-procedure
#+begin_src racket :noweb yes
  (define (make-help-mudsocket-command-for-thing commanding-thing)
    (λ (command-arguments)
      (let ([commanding-thing-universe (thing-universe commanding-thing)])
	(cond [(universe-has-procedure? commanding-thing-universe
					'make-mudsocket-help-response)
	       (universe-procedure commanding-thing-universe
				   'make-mudsocket-help-response)]
	      [else
               (add-string-to-thing-mudsocket-output-buffer!
	       (format

		"You're connected to a qtMUD server named ~a. Your user-name is ~a.\nTo interact, type commands and press ENTER. A few useful commands:\n- commands returns a list of your available commands\n- help returns some generally helpful information\n- who returns a list of currently-connected users."
		(universe-name commanding-thing-universe)
		(thing-name commanding-thing))
commanding-thing)]))))
#+end_src
***** who
#+name: make-who-mudsocket-command-for-thing-procedure
#+begin_src racket :noweb yes
  (define (make-who-mudsocket-command-for-thing commanding-thing)
    (λ (command-arguments)
      (let ([commanding-thing-universe (thing-universe commanding-thing)])
	(cond [(universe-has-procedure? commanding-thing-universe
					'list-mudsocket-current-connections)
	       (add-string-to-thing-mudsocket-output-buffer!
                (format "Users connected now: ~a"
                 (oxfordize-list (map (λ (connected-thing) (thing-name connected-thing)) ((universe-procedure commanding-thing-universe
				   'list-mudsocket-current-connections)))))
                commanding-thing)]
	      [else
               (add-string-to-thing-mudsocket-output-buffer!
	       (format "You're unable to query who is connected to this MUD.")
               commanding-thing)]))))
#+end_src
** plan Politics
*** parent-poliregion
*** poliregions
** draft Talker
*** talker-channels
**** thing-talker-channels
#+name: thing-talker-channels-procedure
#+begin_src racket :noweb yes
  (define (thing-talker-channels queried-thing)
    (thing-quality queried-thing 'talker-channels))
#+end_src
**** thing-has-talker-channels?
#+name: thing-has-talker-channels?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-talker-channels? queried-thing)
    (thing-has-quality? queried-thing 'talker-channels))
#+end_src
**** set-thing-talker-channels!
#+name: set-thing-talker-channels!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-talker-channels! changed-thing new-talker-channels)
    (log-info "Setting ~a Talker-Channels to ~a"
	      (thing-name changed-thing)
	      new-talker-channels)
    (cond [(thing-has-talker-channels? changed-thing)
	   (set-thing-quality! changed-thing 'talker-channels new-talker-channels)]
	  [else
	   (add-talker-channels-to-thing! changed-thing new-talker-channels)]))
#+end_src
**** add-talker-channels-to-thing!
#+name: add-talker-channels-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-talker-channels-to-thing! changed-thing [new-talker-channels '("cq")])
    (unless (thing-has-talker-channels? changed-thing)
      (log-debug "Adding Talker-Channels quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'talker-channels (void))
      (set-thing-talker-channels! changed-thing new-talker-channels)))
#+end_src
** plan Terraforming
*** bioregions
**** thing-bioregions
#+name: thing-bioregions-procedure
#+begin_src racket :noweb yes
  (define (thing-bioregions queried-thing)
    (thing-quality queried-thing 'bioregions))
#+end_src
**** thing-has-bioregions?
#+name: thing-has-bioregions?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-bioregions? queried-thing)
    (thing-has-quality? queried-thing 'bioregions))
#+end_src
**** set-thing-bioregions!
#+name: set-thing-bioregions!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-bioregions! changed-thing new-bioregions-list)
    (log-info "Setting ~a bioregions to ~a"
              (thing-name changed-thing)
              (list-thing-names new-bioregions-list))
    (cond [(thing-has-bioregions? changed-thing)
           (set-thing-quality! changed-thing 'bioregions new-bioregions-list)]
          [else
           (add-bioregions-to-thing! changed-thing new-bioregions-list)]))
#+end_src
**** add-bioregions-to-thing!
#+name: add-bioregions-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-bioregions-to-thing! changed-thing [new-bioregions #f])
    (unless (thing-has-bioregions? changed-thing)
      (log-debug "Adding bioregions quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'bioregions (list))
      (when new-bioregions (set-thing-bioregions! changed-thing new-bioregions))))
#+end_src
**** thing-has-bioregion?
#+name: thing-has-bioregion?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-bioregion? queried-thing potential-bioregion)
    (log-debug "Checking if ~a is a bioregion of ~a"
	       (thing-name potential-bioregion)
	       (thing-name queried-thing))
    (cond [(thing-has-quality? queried-thing 'bioregions)
	   (let ([result (member potential-bioregion (thing-bioregions queried-thing))])
	     (cond [result #t][else #f]))]
	  [else #f]))
#+end_src
**** add-bioregion-to-thing!
#+name: add-bioregion-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-bioregion-to-thing! new-bioregion changed-thing)
    (log-info "Adding ~a to ~a's bioregions."
	      (thing-name new-bioregion)
	      (thing-name changed-thing))
    (unless (thing-has-quality? changed-thing 'bioregions)
      (log-debug "~a doesn't have the bioregions quality: triggering its addition."
		 (thing-name changed-thing))
      (add-bioregions-to-thing! changed-thing)
      (log-debug "Now, moving ahead with adding ~a to ~a's bioregions."
		 (thing-name new-bioregion)
		 (thing-name changed-thing)))
    (set-thing-bioregions! changed-thing (append (thing-bioregions changed-thing) (list new-bioregion))))

#+end_src
**** list-names-of-thing-bioregions
#+name: list-names-of-thing-bioregions-procedure
#+begin_src racket :noweb yes
(define (list-names-of-thing-bioregions queried-thing)
  (list-thing-names (thing-bioregions queried-thing)))
#+end_src
*** elevation
**** thing-elevation
**** add-elevation-to-thing!
**** set-thing-elevation!
**** thing-has-elevation?
*** parent-bioregion
**** thing-parent-bioregion
#+name: thing-parent-bioregion-procedure
#+begin_src racket :noweb yes
  (define (thing-parent-bioregion queried-thing)
    (thing-quality queried-thing 'parent-bioregion))
#+end_src
**** set-thing-parent-bioregion!
#+name: set-thing-parent-bioregion!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-parent-bioregion! changed-thing new-parent-bioregion)
    (log-info "Setting ~a's parent bioregion to ~a"
              (thing-name changed-thing)
              (thing-name new-parent-bioregion))
    (set-thing-quality! changed-thing 'parent-bioregion new-parent-bioregion)
    (unless (thing-has-bioregion? new-parent-bioregion changed-thing)
      (log-debug "~a dosn't contain ~a in its list of bioregions: triggering its addition."
                 (thing-name new-parent-bioregion)
                 (thing-name changed-thing))
      (add-bioregion-to-thing! changed-thing new-parent-bioregion)))
#+end_src
**** thing-has-parent-bioregion?
#+name: thing-has-parent-bioregion?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-parent-bioregion? queried-thing)
    (thing-has-quality? queried-thing 'parent-bioregion))
#+end_src
**** add-parent-bioregion-to-thing!
#+name: add-parent-bioregion-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-parent-bioregion-to-thing! changed-thing new-parent-bioregion)
    (unless (thing-has-parent-bioregion? changed-thing)
      (log-debug "Adding parent bioregion quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'parent-bioregion (void))
      (set-thing-parent-bioregion! changed-thing new-parent-bioregion)))
#+end_src
*** parent-poliregion
*** populations
*** generate-world-plane
#+begin_src racket
#lang racket

(require plot)


(define (clusterize data centroids)
  (for*/fold ([res (map list centroids)])
             ([x (in-list data)])
    (define c (argmin (curryr (metric) x) centroids))
    (dict-set res c (cons x (dict-ref res c)))))
(define (euclidean-distance a b)
  (for/sum ([x (in-vector a)] [y (in-vector b)])
    (sqr (- x y))))
(define metric (make-parameter euclidean-distance))


;; Performs clustering of points in a grid
;; using the nearest neigbour approach and shows
;; clusters in different colors
(define (plot-Voronoi-diagram point-list)
  (define pts
    (for*/list ([x (in-range 0 1 0.005)]
                [y (in-range 0 1 0.005)])
      (vector x y)))

  (define clusters (clusterize pts point-list))

  (plot
   (append
    (for/list ([r (in-list clusters)] [i (in-naturals)])
      (points (rest r) #:color i #:sym 'fullcircle1))
    (list (points point-list #:sym 'fullcircle5 #:fill-color 'white)))))



(define pts
  (for/list ([i 50]) (vector (random) (random))))

(display (plot-Voronoi-diagram pts))
#+end_src
** document User Accounts
*** user-name
**** thing-user-name
#+name: thing-user-name-procedure
#+begin_src racket :noweb yes
  (define (thing-user-name queried-thing)
    (thing-quality queried-thing 'user-name))
#+end_src
**** thing-has-user-name?
#+name: thing-has-user-name?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-user-name? queried-thing)
    (thing-has-quality? queried-thing 'user-name))
#+end_src
**** set-thing-user-name!
#+name: set-thing-user-name!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-user-name! changed-thing new-user-name)
    (log-info "Setting ~a User-Name to ~a"
	      (thing-name changed-thing)
	      new-user-name)
    (cond [(thing-has-user-name? changed-thing)
	   (set-thing-quality! changed-thing 'user-name new-user-name)]
	  [else
	   (add-user-name-to-thing! changed-thing new-user-name)]))
#+end_src
**** add-user-name-to-thing!
#+name: add-user-name-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-user-name-to-thing! changed-thing new-user-name)
    (unless (thing-has-user-name? changed-thing)
      (log-debug "Adding User-Name quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'user-name (void))
      (set-thing-user-name! changed-thing new-user-name)))
#+end_src
*** user-password
**** thing-user-password
#+name: thing-user-password-procedure
#+begin_src racket :noweb yes
  (define (thing-user-password queried-thing)
    (thing-quality queried-thing 'user-password))
#+end_src
**** thing-has-user-password?
#+name: thing-has-user-password?-procedure
#+begin_src racket :noweb yes
  (define (thing-has-user-password? queried-thing)
    (thing-has-quality? queried-thing 'user-password))
#+end_src
**** set-thing-user-password!
#+name: set-thing-user-password!-procedure
#+begin_src racket :noweb yes
  (define (set-thing-user-password! changed-thing new-user-password)
    (log-info "Setting ~a User-Password to ~a"
	      (thing-name changed-thing)
	      new-user-password)
    (cond [(thing-has-user-password? changed-thing)
	   (set-thing-quality! changed-thing 'user-password new-user-password)]
	  [else
	   (add-user-password-to-thing! changed-thing new-user-password)]))
#+end_src
**** add-user-password-to-thing!
#+name: add-user-password-to-thing!-procedure
#+begin_src racket :noweb yes
  (define (add-user-password-to-thing! changed-thing new-user-password)
    (unless (thing-has-user-password? changed-thing)
      (log-debug "Adding User-Password quality to ~a" (thing-name changed-thing))
      (set-thing-quality! changed-thing 'user-password (void))
      (set-thing-user-password! changed-thing new-user-password)))
#+end_src
*** add-user-accounts-to-universe!-event
#+name: add-user-accounts-to-universe!-event-procedure
#+begin_src racket
  (define (add-user-accounts-to-universe!-event
	   [save-file "saved1-user-accounts.rktd"])
    (define user-accounts (make-hash))
    (define (user-account name) (hash-ref user-accounts name))
    (define (user-account? name) (hash-has-key? user-accounts name))
    (define (load-user-accounts)
      (cond [(file-exists? save-file)
	     (set! user-accounts (deserialize-file save-file))]
	    [else
	     (log-info "Invalid save file ~a cannot load accounts."
		       save-file)]))
    (define (register-user-account! reference-thing)
      (let ([name (thing-name reference-thing)])
	(log-info "Registering new user account for thing named ~a" name)
	(hash-set! user-accounts name
		   (make-hash
		    (list
		     (cons 'user-name (thing-user-name reference-thing))
		     (cons 'user-password (thing-user-password reference-thing)))))
	((universe-procedure (thing-universe reference-thing) 'save-user-accounts!))))
    (define (save-user-accounts!)
      (cond [(serializable? user-accounts)
	     (with-output-to-file save-file
	       (λ () (write (serialize user-accounts)))
	       #:exists 'replace)
	     (load-user-accounts)]
	    [else
	     (log-warning "User account data not serializable; data not saved.")]))
    (λ (ticked-universe)
      (log-info "Adding user accounts to universe ~a" (universe-name ticked-universe))
      (set-universe-procedure!
       ticked-universe 'user-account user-account)
      (set-universe-procedure!
       ticked-universe 'user-account? user-account?)
      (set-universe-procedure!
       ticked-universe 'load-user-accounts load-user-accounts)
      (set-universe-procedure!
       ticked-universe 'register-user-account! register-user-account!)
      (set-universe-procedure!
       ticked-universe 'save-user-accounts! save-user-accounts!)
      (set-universe-procedure!
       ticked-universe 'check-user-account-password?
       (λ (queried-user-name provided-password)
         (string=? (hash-ref (hash-ref user-accounts queried-user-name) 'user-password) provided-password)))
      (load-user-accounts)
      ticked-universe))
#+end_src
* MUDs
  :PROPERTIES:
  :header-args: :noweb yes
  :END:
** draft emsMUD
   :PROPERTIES:
   :EXPORT_FILE_NAME: emsmud
   :EXPORT_HUGO_SECTION: programming
   :END:
*/emsMUD/* is a simple MUD written for qtMUD, and the personal playground of emsenn.
#+toc: headlines 1 local
*** Player Guide
Right now there isn't gameplay as such. Sorry!
*** MUD Code
#+toc: headlines 6 local
**** Creation
***** Create the emsVerse
#+name: emsmud-declarations-create-the-emsverse
#+begin_src racket
  (define emsverse (make-universe "emsVerse"))
  (run-universe-logger (make-universe-logger emsverse))
  (define make-thing (make-thing-maker-for-universe emsverse))
#+end_src
****** Create areas
#+name: emsmud-declarations-create-areas
#+begin_src racket
(define clearing (make-thing "grassy clearing"))
(define garden (make-thing "small garden"))
(define home (make-thing "emsenn's home"))
(define emsverse-map (make-map-from-areas
 `((clearing . ,clearing) (garden . ,garden) (home . ,home))))
#+end_src
******* Set area contents
#+name: emsmud-declarations-set-area-contents
#+begin_src racket
(map (λ (area) (set-thing-contents! area '())) emsverse-map)
#+end_src
******* Set area exits
#+name: emsmud-declarations-set-area-exits
#+begin_src racket
  (set-thing-area-exits! clearing `(("garden" . ,garden) ("home" . ,home)))
  (set-thing-area-exits! garden `(("clearing" . ,clearing)))
  (set-thing-area-exits! home `(("out" . ,clearing)))
#+end_src
******* Set area descriptions
#+name: emsmud-declarations-set-area-descriptions
#+begin_src racket
  (set-thing-area-description! clearing
			       "This is a grassy field, roughly 100 meters across, located in a temperate decidious forest. There is a small structure made from coppice poles and woven panels of bark constructed in the western part of the clearing, Near the middle of the clearing is a garden, just south of a large mulberry tree.")
  (set-thing-area-description! garden
			       "This is a garden.")
  (set-thing-area-description! home
			       "This is a small structure made of young pine tree trunks driven into the ground to form a cone, with long planes of wood bark woven between the beams.")
#+end_src
**** Setup game
***** Add library components
#+name: emsmud-declarations-add-library-components
#+begin_src racket
(add-event-to-universe-schedule! (make-mudsocket-tick-event-for-universe emsverse) emsverse)
(add-event-to-universe-schedule! (add-user-accounts-to-universe!-event "emsmud-user-accounts.rktd") emsverse)
#+end_src
***** Configure MUDSocket
#+name: emsmud-declarations-configure-mudsocket
#+begin_src racket
  (set-universe-procedure! emsverse 'handle-mudsocket-connection
   (λ (connected-thing)
    (add-string-to-thing-mudsocket-output-buffer! "You've connected to emsMUD, a small virtual world created by emsenn. Please, enter your [desired] user-name and press ENTER to connect [or register a new account]." connected-thing)))

  (set-universe-procedure!
   emsverse 'handle-mudsocket-login
   (λ (connected-thing)
     (add-string-to-thing-mudsocket-output-buffer!
      (format
       "Welcome to emsMUD, ~a. Interact by typing commands and pressing ENTER. Try starting with the \"help\" command.\n\nYou form, a fully-realized adult homo sapien, clothed in buckskin, into the universe."
       (thing-name connected-thing))
      connected-thing)
     (add-thing-to-thing-contents! connected-thing clearing)
     (add-new-mudsocket-commands-to-thing!
      (list
       (cons "look" (make-look-mudsocket-command-for-thing connected-thing))
       (cons "move" (make-move-mudsocket-command-for-thing connected-thing)))
      connected-thing)))
#+end_src
**** Start time

#+name: emsmud-declarations-start-time
#+begin_src racket
(define emsmud (run-universe emsverse))
#+end_src
** draft Johara-MUD
   :PROPERTIES:
   :EXPORT_FILE_NAME: johara-mud
   :END:
The */Johara-MUD/* is the first MUD world written for the qtMUD engine. It's created through a series of declarations that make objects, modify them, and establish relationships. The following sections divide those declarations into a rough chronology, though much of the universe was created (from an in-universe perspective) in the first moment of time.
*** Creation
**** Creation of the Joharaverse
#+name: johara-mud-declarations-creation
#+begin_src racket
  (define joharaverse (make-universe "Joharaverse"))
  (run-universe-logger (make-universe-logger joharaverse))
  (set-universe-procedure!
   joharaverse 'handle-mudsocket-connection
   (λ (connected-thing)
     (add-string-to-thing-mudsocket-output-buffer!
     "Welcome to Johara settlement, weary traveler. Enter your [desired] user-name and press ENTER to connect [or register a new account]."
     connected-thing))
  (set-universe-procedure!
   joharaverse 'handle-mudsocket-login
   (λ (connected-thing)
     (add-string-to-thing-mudsocket-output-buffer!
     "You rise up from the soil of Johara Forest, just outside the settlement, and wander inside."
     connected-thing))
#+end_src
**** Creation of the game areas
***** Establishment of spatial relationships betwen game areas
#+name: johara-mud-declarations
#+begin_src racket
  ; wee universe
  ; make the areas
  (define make-thing
    (make-thing-maker-for-universe joharaverse))
  (define johara-forest-east
    (make-thing "Johara Forest, east"))
  (define johara-forest-west
    (make-thing "Johara Forest, west"))
  (define johara-settlement
    (make-thing "Johara settlement"))
  (define coastwatch-road
    (make-thing "Coastwatch Road"))
  (define meri-marshes
    (make-thing "Meri Marshes"))
  ; set up spatial relationships
;  (set-thing-area-exits!
;   johara-settlement
;   (list
;    (cons "forest" johara-forest-west)))
;  (set-thing-area-exits!
;   johara-forest-west
;   (list
;    (cons "east" johara-forest-east)
;    (cons "road" coastwatch-road)))
;  (set-thing-area-exits!
;   johara-forest-east
;   (list
;    (cons "west" johara-forest-west)))
;  (set-thing-area-exits!
;   coastwatch-road
;   (list
;    (cons "north" johara-forest-west)
;    (cons "marshes" meri-marshes)))
  ; add descriptions
;  (set-thing-area-description!
;   johara-settlememnt
;   "This is Johara settlement, a village of about 350 people living in timber and plaster buildings. It is situated in Johara Forest, on the southern slope of the Meri Mountains.")
;  (set-thing-area-description!
;   johara-forest-east
;   "")
;  (set-thing-area-description!
;   johara-forest-west
;   "")
;  (set-thing-area-description!
;   coastwatch-road
;   "")
;  (set-thing-area-description!
;   meri-marshes
;   "")
  ; make the humans that live in johara settlement
;  (define johara-resident (make-thing "Human resident of Johara"))
  ; move the humans into Johara settlement
;  (set-thing-settlement-populations!
;   johara-settlement
;   (list
;    (cons johara-resident 366)))
  ; add facilities to the settlement
  ; make plants for the forest
  ; make animals for the forest
  ; move them in
#+end_src

*** Addition of MUD basics
#+name: johara-mud-declarations-addition-of-mud-basics
#+begin_src racket
(add-event-to-universe-schedule! (make-mudsocket-tick-event-for-universe joharaverse) joharaverse)
(add-event-to-universe-schedule! (add-user-accounts-to-universe!-event) joharaverse)
#+end_src
*** Start of time
#+name: johara-mud-declarations-start-of-time
#+begin_src racket
(define johara-mud (run-universe joharaverse))
#+end_src
* Logs
  :PROPERTIES:
  :EXPORT_HUGO_SECTION*: logs
  :EXPORT_HUGO_TYPE: log
  :END:
- 2002
  - Started with the Discworld MUD library that was publicly accessible at that time.
  - Quickly switched to Dead Souls
- 2004
  - Tried to use pure FluffOS and build up from that.
- 2007
  - Decided to start my own MUD engine, in Pike.
- 2009
  - Switched to Sapidlib
- 2010
  - Tried to build another FluffOS-based library.
- 2013
  - Started my own MUD engine in Python, called qtMUD, for "quality of things"
- 2019
  - Started my own MUD engine in Elisp, but quickly switched to Racket
  - Worked on the Racket codebase from early October until late November.
- 2020
  - July :: Picked back up the Racket codebase, but realized it was really clunky. Started on a rewrite.
  - August :: Started another rewrite, mid-rewrite. Then another.
** 2020
#+toc: headlines 3 local
*** 2020-08 August
**** 2020-08-12 Wednesday
***** [2020-08-12 Wed 22:24]
Alright so I basically got frustrated at the rather useless handler system that was littering everything up, so I started writing the whole Racket-MUD over again, again.

My re-write so far has focused on the things part of things, because I got just... tired of working with the server part of things. I'll pick it back up soon.

As is, I've written out some procedures for making things and interacting with their qualities, and some procedures for two companion qualities: /bioregions/ and /parent bioregion/.

I wrote in earlier logs that one of the first things I'd like to allow for is animate things that can collect blackberries.

So, rabbits and blackberries. =(make-thing-eat-food rabbit blackberry)=

This should

1) Make sure the rabbit has the action points to do the thing
2) make sure the rabbit will at blackberries (on a list familiar foods)
   1) unless forced
3) destroy the blackberry
4) give some action points to the rabbit
   1) look at the blackberry's nutritional value
   2) and the rabbit's metabolism needs

#+begin_src racket
(define rabbit (make-thing "rabbit"))
(define blackberry (make-thing "blackberry"))
(set-thing-metabolism! rabbit (make-small-mammal-metabolism))
(set-thing-nutrition! blackberry (list (cons 'sugar 1.2)))
(make-thing-eat-food! rabbit blackberry)
#+end_src
**** 2020-08-13 Thursday
***** [2020-08-13 Thu 08:42]
Yesterday I took the day to do some fun work, making procedures for the /bioregions/ and /parent-bioregion/ thing. I'm not entirely sure what the implications of those qualities will be, how they'll be used in gameplay, but establishing some basic types of areas seemed like a nice first step. (I mean, even on their own, knowing that Teraum is the parent bioregion of the Barmland provides some sense of orientation.

Today I'd like to get back to looking at the MUD engine/server itself, now that I've abandoned the pretense of even partially following a functional programming paradigm.
**** 2020-08-14 Friday
***** [2020-08-14 Fri 13:57]
Yesterday I made decent progress on the engine itself, and the MUDSocket stuff. Today's focus is on user accounts, commands, and some basic commands.
***** [2020-08-14 Fri 18:38]
Wow. I actually have a MUD you can connect to and enter at least one command, =commands=, which tells you what commands you have.

It took so much tinkering to end up basically back where I started, but I'm a lot happier with the code.

The Org-mode file itself, that holds all the code, and the organization of the procedures across Racket files... is something I'm less pleased with. I'm going to give that some thought, while also thinking about what's next in terms of adding to the MUD.
**** 2020-08-16 Sunday
***** [2020-08-16 Sun 10:21]
      :PROPERTIES:
      :EXPORT_FILE_NAME: 2020-08-16-10-21
      :EXPORT_DATE: [2020-08-16 Sun 10:21]
      :END:
So, I've changed the name of the MUD engine, from /Racket-MUD/ to /qtMUD/.

qtMUD is the name I used for my Python MUD engine, and I really liked it but didn't want to reuse it for an engine in an entirely different language, especially when I wasn't sure if it'd work the same way. But, it does (more or less) and it's been a few years without anyone else touching the Python-language qtMUD, so I'm moving back to the name.

For the first MUD I'm building with qtMUD I decided to go with something relatively simple: players will spawn in a village in a forest, and will be able to =explore= the village and forest. Exploration results in acquiring resources like berries or branches, that can be =gifted= to the village. This'll influence the relationship between the village and player, potentially resulting in reciprocal gifts. Certain items like berries can be eaten to restore energy points, which'll be used to explore and move around th eworld.

This MUD will require the MUDSocket, Talker, and User Account components of the qtMUD library, and will prompt me to write a few others. The settlement and forest will be /areas/, which will each have a /description/, /surface area/, and one or more /exits/.

They'll also have /populations/ of plants and animals: the quantity of a population against the area's surface area will influence the likelihood of finding something.

The village will also have a quality of /gratitude/, which will track gift-givers and recipients, and it'll occasionally give gifts based on whats in its /inventory/: filled by players =gifting= things they collect.

#+begin_src txt
> look
Johara settlement, in Johara Forest. [10/10]
> explore
You explore the settlement and find three scraps of fabric. [8/10]
> explore --target=nails
You explore the settlement and don't find any nails. [6/10]
> explore --target=nails duration=1
You explore the settlement and find one nail. [5/10]
> inventory
You are holding: three scraps of fabric, one nail, and one sandwich.
> gift --recipient=here item=fabric quantity=3
You gift three fabric to the settlement. [4/10]
> eat sandwich
You eat the sandwich. [8/10]
> move forest
You move to western Johara Forest.
> explore
You run into a blackbear while exploring, and flee back to town, dropping everything.
> look
Johara settlement, in Johara Forest. [0/10]
#+end_src
**** 2020-08-18 Tuesday
***** [2020-08-18 Tue 18:34]
      :PROPERTIES:
      :EXPORT_FILE_NAME: 2020-08-18-18-34
      :EXPORT_DATE: [2020-08-18 Tue 18:34]
      :END:
      Oh gosh I've been bad about taking logs recently when I tinker on the MUD. In part because of how I've been tinkering: largely bouncing across the whole project. I've also been reorganizing a lot of how the project is laid out, so I have to keep focused until I'm done.

      I also haven't done any real consideration of how to track plans - or done anything to set up a git repository!

      In order to that, I need to clean up the Org-mode file which holds the project work. This leads me to wonder if there's any sort of cross-compatibility between Org-mode and Git, or... I'm not sure exactly what I'd make use of.
* Complete Files
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: programming/qtmud/files/
  :header-args: :noweb yes
  :END:
** qtmud.rkt
#+name: qtmud.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/qtmud.rkt
  #lang racket

  (require racket/serialize)

  (require uuid)

  (provide (struct-out universe)
	   (struct-out thing)
	   deserialize-file
	   oxfordize-list
           make-universe-logger
           run-universe-logger
	   make-universe
	   increment-universe-tick-count!
	   add-event-to-universe-schedule!
	   add-thing-to-universe-things!
           universe-has-procedure?
	   universe-procedure
	   set-universe-procedure!
	   tick-universe
	   run-universe
	   make-thing
	   list-thing-names
	   thing-has-quality?
	   thing-quality
	   set-thing-quality!
	   make-thing-maker-for-universe)

  <<deserialize-file-procedure>>
  <<oxfordize-list-procedure>>
  <<make-universe-logger-procedure>>
  <<run-universe-logger-procedure>>

  <<universe-struct>>
  <<make-universe-procedure>>
  <<increment-universe-tick-count!-procedure>>
  <<add-event-to-universe-schedule!-procedure>>
  <<add-thing-to-universe-things!-procedure>>
  <<universe-has-procedure?-procedure>>
  <<universe-procedure-procedure>>
  <<set-universe-procedure!-procedure>>
  <<tick-universe-procedure>>
  <<run-universe-procedure>>

  <<thing-struct>>
  <<make-thing-procedure>>
  <<list-thing-names-procedure>>
  <<thing-has-quality?-procedure>>
  <<thing-quality-procedure>>
  <<set-thing-quality!-procedure>>
  <<make-thing-maker-for-universe-procedure>>
#+end_src
** components/
*** animation.rkt
#+name: animation.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/animation.rkt
#lang racket

(require "../qtmud.rkt"
         "./areas.rkt"
         "./containers.rkt"
         "./mudsocket.rkt")

(provide make-thing-look-at-thing
         make-look-mudsocket-command-for-thing
	 make-move-mudsocket-command-for-thing)

<<make-thing-look-at-thing-procedure>>
<<make-look-mudsocket-command-for-thing-procedure>>
<<make-move-mudsocket-command-for-thing-procedure>>
#+end_src
*** areas.rkt
#+name: areas.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/areas.rkt
  #lang racket

  (require "../qtmud.rkt")

  (provide thing-area-description
	   thing-has-area-description?
	   set-thing-area-description!
	   add-area-description-to-thing!
	   thing-area-exits
	   thing-has-area-exits?
	   set-thing-area-exits!
	   add-area-exits-to-thing!
           make-map-from-areas)

<<thing-area-description-procedure>>
<<thing-has-area-description?-procedure>>
<<set-thing-area-description!-procedure>>
<<add-area-description-to-thing!-procedure>>
<<thing-area-exits-procedure>>
<<thing-has-area-exits?-procedure>>
<<set-thing-area-exits!-procedure>>
<<add-area-exits-to-thing!-procedure>>
<<make-map-from-areas-procedure>>
#+end_src
*** containers.rkt
#+name: containers.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/containers.rkt
  #lang racket

  (require "../qtmud.rkt")

  (provide thing-contents
	   thing-has-contents?
	   set-thing-contents!
	   add-contents-to-thing!
	   add-thing-to-thing-contents!
	   remove-thing-from-thing-contents!
	   thing-parent-container
	   thing-has-parent-container?
	   set-thing-parent-container!
	   add-parent-container-to-thing!)

  <<thing-contents-procedure>>
  <<thing-has-contents?-procedure>>
  <<set-thing-contents!-procedure>>
  <<add-contents-to-thing!-procedure>>
  <<add-thing-to-thing-contents!-procedure>>
  <<remove-thing-from-thing-contents!-procedure>>
  <<thing-parent-container-procedure>>
  <<thing-has-parent-container?-procedure>>
  <<set-thing-parent-container!-procedure>>
  <<add-parent-container-to-thing!-procedure>>
#+end_src
*** mudsocket.rkt
#+name: mudsocket.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/mudsocket.rkt
#lang racket

(require uuid)

(require "../qtmud.rkt"
         "./talker.rkt"
         "./user-accounts.rkt")

(provide thing-mudsocket-commands
	 thing-has-mudsocket-commands?
	   set-thing-mudsocket-commands!
	   add-mudsocket-commands-to-thing!
           add-mudsocket-command-to-thing!
           add-new-mudsocket-commands-to-thing!
	   thing-mudsocket-in
	   thing-has-mudsocket-in?
	   set-thing-mudsocket-in!
	   add-mudsocket-in-to-thing!
	   thing-mudsocket-input-buffer
	   thing-has-mudsocket-input-buffer?
	   set-thing-mudsocket-input-buffer!
	   add-mudsocket-input-buffer-to-thing!
	   thing-mudsocket-ip
	   thing-has-mudsocket-ip?
	   set-thing-mudsocket-ip!
	   add-mudsocket-ip-to-thing!
	   thing-mudsocket-out
	   thing-has-mudsocket-out?
	   set-thing-mudsocket-out!
	   add-mudsocket-out-to-thing!
	   thing-mudsocket-output-buffer
	   thing-has-mudsocket-output-buffer?
	   set-thing-mudsocket-output-buffer!
	   add-mudsocket-output-buffer-to-thing!
           clear-thing-mudsocket-output-buffer!
           add-string-to-thing-mudsocket-output-buffer!
	   thing-mudsocket-parser
	   thing-has-mudsocket-parser?
	   set-thing-mudsocket-parser!
	   add-mudsocket-parser-to-thing!
	   make-mudsocket-parser-for-thing
	   make-mudsocket-login-parser-for-thing
	   thing-mudsocket-port
	   thing-has-mudsocket-port?
	   set-thing-mudsocket-port!
	   add-mudsocket-port-to-thing!
	   thing-mudsocket-sender
	   thing-has-mudsocket-sender?
	   set-thing-mudsocket-sender!
	   add-mudsocket-sender-to-thing!
	   make-mudsocket-sender-for-thing
	   make-commands-mudsocket-command-for-thing
           make-help-mudsocket-command-for-thing
           make-who-mudsocket-command-for-thing
	   make-mudsocket-tick-event-for-universe)

  <<thing-mudsocket-commands-procedure>>
  <<thing-has-mudsocket-commands?-procedure>>
  <<set-thing-mudsocket-commands!-procedure>>
  <<add-mudsocket-commands-to-thing!-procedure>>
  <<add-mudsocket-command-to-thing!-procedure>>
  <<add-new-mudsocket-commands-to-thing!-procedure>>

  <<thing-mudsocket-in-procedure>>
  <<thing-has-mudsocket-in?-procedure>>
  <<set-thing-mudsocket-in!-procedure>>
  <<add-mudsocket-in-to-thing!-procedure>>

  <<thing-mudsocket-input-buffer-procedure>>
  <<thing-has-mudsocket-input-buffer?-procedure>>
  <<set-thing-mudsocket-input-buffer!-procedure>>
  <<add-mudsocket-input-buffer-to-thing!-procedure>>

  <<thing-mudsocket-ip-procedure>>
  <<thing-has-mudsocket-ip?-procedure>>
  <<set-thing-mudsocket-ip!-procedure>>
  <<add-mudsocket-ip-to-thing!-procedure>>

  <<thing-mudsocket-out-procedure>>
  <<thing-has-mudsocket-out?-procedure>>
  <<set-thing-mudsocket-out!-procedure>>
  <<add-mudsocket-out-to-thing!-procedure>>

  <<thing-mudsocket-output-buffer-procedure>>
  <<thing-has-mudsocket-output-buffer?-procedure>>
  <<set-thing-mudsocket-output-buffer!-procedure>>
  <<add-mudsocket-output-buffer-to-thing!-procedure>>
  <<clear-thing-mudsocket-output-buffer!-procedure>>
  <<add-string-to-thing-mudsocket-output-buffer!-procedure>>

  <<thing-mudsocket-parser-procedure>>
  <<thing-has-mudsocket-parser?-procedure>>
  <<set-thing-mudsocket-parser!-procedure>>
  <<add-mudsocket-parser-to-thing!-procedure>>
  <<make-mudsocket-parser-for-thing-procedure>>
  <<make-mudsocket-login-parser-for-thing-procedure>>

  <<thing-mudsocket-port-procedure>>
  <<thing-has-mudsocket-port?-procedure>>
  <<set-thing-mudsocket-port!-procedure>>
  <<add-mudsocket-port-to-thing!-procedure>>

  <<thing-mudsocket-sender-procedure>>
  <<thing-has-mudsocket-sender?-procedure>>
  <<set-thing-mudsocket-sender!-procedure>>
  <<add-mudsocket-sender-to-thing!-procedure>>
  <<make-mudsocket-sender-for-thing-procedure>>

  <<make-commands-mudsocket-command-for-thing-procedure>>
  <<make-help-mudsocket-command-for-thing-procedure>>
  <<make-who-mudsocket-command-for-thing-procedure>>

<<make-mudsocket-tick-event-for-universe>>

#+end_src
*** politics.rkt
#+name politics.rkt
#+begin_src racket
#+end_src
*** talker.rkt
#+name: talker.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/talker.rkt
  #lang racket

  (require "../qtmud.rkt")

  (provide thing-talker-channels
	  thing-has-talker-channels?
	  set-thing-talker-channels!
	  add-talker-channels-to-thing!)
    <<thing-talker-channels-procedure>>
    <<thing-has-talker-channels?-procedure>>
    <<set-thing-talker-channels!-procedure>>
    <<add-talker-channels-to-thing!-procedure>>

#+end_src
*** terraforming.rkt
#+name: terraforming.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/terraforming.rkt
#lang racket

(require "../qtmud.rkt")

(provide thing-bioregions
         add-bioregions-to-thing!
	 set-thing-bioregions!
	 thing-has-bioregions?
         thing-has-bioregion?
	 add-bioregion-to-thing!
         thing-parent-bioregion
         set-thing-parent-bioregion!
         thing-has-parent-bioregion?
         add-parent-bioregion-to-thing!)
  <<thing-bioregions-procedure>>
  <<add-bioregions-to-thing!-procedure>>
  <<set-thing-bioregions!-procedure>>
  <<thing-has-bioregions?-procedure>>
  <<thing-has-bioregion?-procedure>>
  <<add-bioregion-to-thing!-procedure>>
  <<list-names-of-thing-bioregions-procedure>>


  <<thing-parent-bioregion-procedure>>
  <<set-thing-parent-bioregion!-procedure>>
  <<thing-has-parent-bioregion?-procedure>>
  <<add-parent-bioregion-to-thing!-procedure>>
#+end_src
*** user-accounts.rkt
#+name: user-accounts.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/components/user-accounts.rkt
#lang racket

(require racket/serialize)

(require "../qtmud.rkt")

(provide 	   thing-user-name
	   thing-has-user-name?
	   set-thing-user-name!
	   add-user-name-to-thing!
	   thing-user-password
	   thing-has-user-password?
	   set-thing-user-password!
	   add-user-password-to-thing!
	   add-user-accounts-to-universe!-event)
  <<thing-user-name-procedure>>
  <<thing-has-user-name?-procedure>>
  <<set-thing-user-name!-procedure>>
  <<add-user-name-to-thing!-procedure>>

  <<thing-user-password-procedure>>
  <<thing-has-user-password?-procedure>>
  <<set-thing-user-password!-procedure>>
  <<add-user-password-to-thing!-procedure>>
<<add-user-accounts-to-universe!-event-procedure>>

#+end_src
** muds/
*** emsmud.rkt
#+name: emsmud.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/muds/emsmud.rkt
#lang racket

(require "../qtmud.rkt"
         "../components/areas.rkt"
         "../components/animation.rkt"
         "../components/containers.rkt"
         "../components/mudsocket.rkt"
         "../components/talker.rkt"
         "../components/user-accounts.rkt")<
<<emsmud-declarations-create-the-emsverse>>
<<emsmud-declarations-create-areas>>
<<emsmud-declarations-set-area-exits>>
<<emsmud-declarations-set-area-descriptions>>
<<emsmud-declarations-add-library-components>>
<<emsmud-declarations-configure-mudsocket>>
<<emsmud-declarations-start-time>>
#+end_src
*** johara-mud.rkt
#+name: johara-mud.rkt
#+begin_src racket :mkdirp yes :tangle ~/racket/qtmud/muds/johara-mud.rkt
#lang racket

(require "../qtmud.rkt"
         "../components/mudsocket.rkt"
         "../components/talker.rkt"
         "../components/user-accounts.rkt")

<<johara-mud-declarations-creation>>
<<johara-mud-declarations-addition-of-mud-basics>>
<<johara-mud-declarations-start-of-time>>
#+end_src
)
