#+title: qtMUD
#+description: Software for running traditionally text-interface services, typically role-playing games.
qtMUD is a piece of software for running (traditionally) text-interface services, which are typically role-playing games.

What follows is the software's source code, including tests and demonstrations. Please note this project is in early development.

Code is divided into the following sections:
#+toc: headlines 2 local
* Engine
** Logging & Error Handling
** Utilities
*** §
#+name: §-procedure
#+begin_src racket
(define (§ . s) (string-join s ""))
#+end_src
*** Deserialize file
#+name: deserialize-file-procedure
#+begin_src racket
(define (deserialize-file serialized-file)
              (with-input-from-file serialized-file
                (λ () (deserialize (read)))))
#+end_src
*** Replace symbols in list with strings
#+name: symbols->strings-procedure
#+begin_src racket
(define (symbols->strings mixed-list)
              (map (λ (element)
                     (cond [(symbol? element)
                            (symbol->string element)]
                           [else element]))
                   mixed-list))
#+end_src
*** Oxfordize list
#+name: oxfordize-list-procedure
#+begin_src racket
  (define (oxfordize-list string-list)
		(cond [(null? string-list)
		       (raise-argument-error 'oxfordize-list
					     "listof string?"
					     string-list)]
		      [(null? (cdr string-list))
		       (car string-list)]
		      [(null? (cddr string-list))
		       (string-join string-list " and ")]
		      [else
		       (string-join string-list ", "
				    #:before-first ""
				    #:before-last ", and ")]))
#+end_src
*** Join list of strings and symbols as symbol
#+name: join-strings-and-symbols-as-symbol-procedure
#+begin_src racket
  (define (join-strings-and-symbols-as-symbol unjoined-list
					     [string-separator ""])
	   (string->symbol
	    (string-join
	     (symbols->strings unjoined-list)
	     string-separator)))
#+end_src
*** Generate simple ID
#+name: generate-simple-id-procedure
#+begin_src racket
  (define (generate-simple-id)
    (substring (uuid-string) 0 8))
#+end_src
*** Make qtMUD logger
#+name: make-qtmud-logger-procedure
#+begin_src racket
(define (make-qtmud-logger [loglevel 'info])
  (define qtmud-log
    (make-logger 'qtMUD))
  (define qtmud-log-receiver
    (make-log-receiver qtmud-log loglevel))
  (cons qtmud-log qtmud-log-receiver))
#+end_src
*** Run qtMUD logger
#+name: run-qtmud-logger-procedure
#+begin_src racket
(define (run-qtmud-logger qtmud-logger)
  (let ([qtmud-log (car qtmud-logger)]
	[qtmud-log-receiver (cdr qtmud-logger)])
    (current-logger qtmud-log)
    (thread (λ ()
	      (let log-loop ()
		(define log-vector (sync qtmud-log-receiver))
		(let ([log-level (vector-ref log-vector 0)]
		      [log-string (substring
				   (vector-ref log-vector 1)
				   7
				   (length (string->list
					    (vector-ref log-vector 1))))])
		  (cond[ (eq? log-level 'debug)
			 (display (format ">>> \"~a\"\n"
				 log-string))]
			[else
			 (display (format "~a\n" log-string))]))
		(log-loop))))))
#+end_src
** Creating & changing universes
#+name: universe-struct
#+begin_src racket
  (struct universe
    (name tick-count schedule things procedures)
    #:mutable)
#+end_src
*** Increment universe tick count
#+name: increment-universe-tick-count!-procedure
#+begin_src racket
  (define (increment-universe-tick-count! incremented-universe
					  [addition 1])
    (set-universe-tick-count!
     incremented-universe
     (+ (universe-tick-count incremented-universe)
	addition)))
#+end_src
*** Add event to universe schedule
#+name: add-event-to-universe-schedule!-procedure
#+begin_src racket
  (define (add-event-to-universe-schedule! new-event changed-universe)
    (cond [(procedure? new-event)
	   (cond [(universe? changed-universe)
		  (define current-schedule (universe-schedule changed-universe))
		  (set-universe-schedule! changed-universe
					  (append
					   current-schedule
					   (list new-event)))]
		 [else
		  (raise-argument-error 'add-event-to-universe-schedule!
					"universe?"
					changed-universe)])]
	  [else
	   (raise-argument-error 'add-event-to-universe-schedule!
				 "procedure?"
				 new-event)]))
#+end_src
*** Add thing to universe things
#+name: add-thing-to-universe-things!-procedure
#+begin_src racket
(define (add-thing-to-universe-things! new-thing changed-universe)
  (set-universe-things! changed-universe (append (universe-things changed-universe) (list new-thing))))
#+end_src
*** Universe has procedure?
#+name: universe-has-procedure?-procedure
#+begin_src racket
(define (universe-has-procedure? queried-universe queried-procedure)
  (hash-has-key? (universe-procedures queried-universe) queried-procedure))
#+end_src
*** Universe procedure
#+name: universe-procedure-procedure
#+begin_src racket
(define (universe-procedure queried-universe queried-procedure)
  (cond [(universe-has-procedure? queried-universe queried-procedure)
	 (hash-ref (universe-procedures queried-universe) queried-procedure)]
	[else
	 (log-warning "Tried to use procedure ~a from universe ~a, but it doesn't exist."
		      queried-procedure
		      (universe-name queried-universe))]))
#+end_src
*** Set universe procedure
#+name: set-universe-procedure!-procedure
#+begin_src racket
(define (set-universe-procedure! changed-universe new-procedure-key new-procedure)
  (hash-set!
   (universe-procedures
    changed-universe)
   new-procedure-key
   new-procedure))
#+end_src
*** Add procedures to universe
#+name: add-procedures-to-universe!-procedure
#+begin_src racket
  (define (add-procedures-to-universe! procedures-list target-universe)
    (let ([length-of-procedures-list (length procedures-list)]
	  [target-universe-name (universe-name target-universe)]
	  [target-universe-procedures (universe-procedures target-universe)])
      (cond [(> length-of-procedures-list 0)
	     (log-info "Adding ~a new procedure~a to ~a:\n  ~a"
		       length-of-procedures-list
		       target-universe-name
		       (cond [(> length-of-procedures-list 1) "s "]
			     [else " "])
		       (string-join
			(map (λ (p)
			       (symbol->string (car p)))
			     procedures-list)
				    "\n  "))
	     (map (λ (added-procedure)
		    (set-universe-procedure! target-universe
					     (car added-procedure)
					     (cdr added-procedure)))
		  procedures-list)]
	    [else
	     (log-warning "Tried to add an empty list of procedures to ~a"
			  target-universe-name)
	     #f])))
#+end_src
** Creating & changing things
#+name: thing-struct
#+begin_src racket
(struct thing
  (name universe grammar qualities procedures)
  #:mutable)
#+end_src
*** Thing has procedure?
#+name: thing-has-procedure?-procedure
#+begin_src racket
(define (thing-has-procedure? queried-thing queried-procedure)
  (cond [(hash-has-key? (thing-procedures queried-thing) queried-procedure) #t]
        [else #f]))
#+end_src
*** Thing has quality?
#+name: thing-has-quality?-procedure
#+begin_src racket
(define (thing-has-quality? queried-thing queried-quality)
  (let ([queried-thing-name (thing-name queried-thing)]
	[queried-thing-universe
	 (cond [(thing-has-universe? queried-thing)
		(thing-universe queried-thing)]
	       [else #f])])
    (log-debug "Checking if ~a has ~a quality."
	     queried-thing-name queried-quality)
    (let ([thing-has-quality?-procedure-key
	   (join-strings-and-symbols-as-symbol
	    (list "thing-has-" queried-quality "?"))])
    (cond [(thing-has-procedure? queried-thing thing-has-quality?-procedure-key)
	   (log-debug "~a has a procedure for checking itself for ~a quality; using it."
		      queried-thing-name queried-quality)
	   ((thing-procedure queried-thing thing-has-quality?-procedure-key))]
	  [(and queried-thing-universe
		(universe-has-procedure? queried-thing-universe
					 thing-has-quality?-procedure-key))
	   (log-debug "~a's universe, ~a, has a procedure for checking if ~a has ~a quality; using it."
		      queried-thing-name (universe-name queried-thing-universe)
		      queried-quality)
	   ((universe-procedure queried-thing-universe
				thing-has-quality?-procedure-key)
	    queried-thing)]
	  [else
	   (let ([queried-thing-qualities (thing-qualities queried-thing)])
	     (cond [(hash-has-key? queried-thing-qualities queried-quality)
		    #t]
		   [else #f]))]))))
#+end_src
*** Thing has universe?
#+name: thing-has-universe?-procedure
#+begin_src racket

(define (thing-has-universe? queried-thing)
  (cond [(thing-universe queried-thing) #t][else #f]))
#+end_src
*** Thing quality
#+name: thing-quality-procedure
#+begin_src racket
(define (thing-quality queried-thing queried-quality)
  (define queried-thing-name (thing-name queried-thing))
  (define queried-thing-universe
    (cond [(thing-has-universe? queried-thing)
	   (thing-universe queried-thing)]
	  [else #f]))
  (log-debug "Checking the value of ~a's ~a quality."
	     queried-thing-name queried-quality)
  (let ([thing-quality-procedure-key
	 (join-strings-and-symbols-as-symbol
	  (list "thing-" queried-quality))])
    (cond [(thing-has-procedure? queried-thing thing-quality-procedure-key)
	   (log-debug "~a has a procedure for checking the value of its own ~a quality: using it."
		      queried-thing-name queried-quality)
	   ((thing-procedure queried-thing thing-quality-procedure-key)
	    queried-thing)]
	  [(and queried-thing-universe
		(universe-has-procedure? queried-thing-universe
					 thing-quality-procedure-key))
	   (log-debug "~a's universe, ~a, has a procedure for checking the value of ~a's ~a quality: using it."
		      queried-thing-name
		      (universe-name queried-thing-universe)
		      queried-quality)
	   ((universe-procedure queried-thing-universe thing-quality-procedure-key)
	    queried-thing-name)]
	  [else
	   (cond [(thing-has-quality? queried-thing queried-quality)
		  (hash-ref (thing-qualities queried-thing) queried-quality)]
		 [else (log-error "~a doesn't have the ~a quality."
			      queried-thing-name queried-quality)])])))
#+end_src
*** Thing procedure
#+name: thing-procedure-procedure
#+begin_src racket
(define (thing-procedure queried-universe queried-procedure)
  (cond [(universe-has-procedure? queried-universe queried-procedure)
	 (hash-ref (thing-procedures queried-universe) queried-procedure)]
	[else
	 (log-warning "Tried to use procedure ~a from universe ~a, but it doesn't exist."
		      queried-procedure
		      (universe-name queried-universe))]))
#+end_src
*** Set thing quality
#+name: set-thing-quality!-procedure
#+begin_src racket
(define (set-thing-quality! changed-thing changed-quality new-value [add-quality? #f])
  (cond [(or add-quality? (thing-has-quality? changed-thing changed-quality))
	 (let ([changed-thing-name (thing-name changed-thing)]
	       [changed-thing-universe
		(cond [(thing-has-universe? changed-thing)
		       (thing-universe changed-thing)]
		      [else #f])]
	       [set-thing-quality!-procedure-key
		(join-strings-and-symbols-as-symbol
		 (list "set-thing-" changed-quality "!"))])
	   (log-debug "Setting ~a's ~a quality to ~a."
		      changed-thing-name changed-quality new-value)
	   (cond [(thing-has-procedure? changed-thing set-thing-quality!-procedure-key)
		  (log-debug "~a has a procedure for setting its own ~a quality: using it."
			     changed-thing-name changed-quality)
		  ((thing-procedure changed-thing set-thing-quality!-procedure-key)
		   new-value)]
		 [(and changed-thing-universe
		       (universe-has-procedure? changed-thing-universe
						set-thing-quality!-procedure-key))
		  (log-debug "~a's universe, ~a, has a procedure for setting ~a's ~a quality: using it."
			     changed-thing-name
			     (universe-name changed-thing-universe)
			     changed-thing-name changed-quality)
		  ((universe-procedure changed-thing-universe
				       set-thing-quality!-procedure-key)
		   changed-thing new-value)]
		 [else
		  (let ([changed-thing-qualities (thing-qualities changed-thing)])
		    (hash-set! changed-thing-qualities changed-quality new-value))]))]
	[else
	 (error "~a doesn't have the ~a quality."
		(thing-name changed-thing) changed-quality)]))
#+end_src
*** Add string to thing quality
#+name: add-string-to-thing-quality!-procedure
#+begin_src racket
(define (add-string-to-thing-quality! input-string changed-thing changed-quality)
  (let ([changed-thing-name (thing-name changed-thing)]
	[changed-thing-universe
	 (cond [(thing-has-universe? changed-thing)
		(thing-universe changed-thing)]
	       [else #f])]
	[procedure-key
	 (join-strings-and-symbols-as-symbol
	  (list "add-string-to-thing-" changed-quality "!"))])
    (cond [(thing-has-procedure? changed-thing procedure-key)
	   ((thing-procedure changed-thing procedure-key) input-string)]
	  [(and changed-thing-universe
		(universe-has-procedure? changed-thing-universe
					 procedure-key))
	   ((universe-procedure changed-thing-universe procedure-key)
	    changed-thing input-string)]
	  [else
	   (set-thing-quality! changed-thing
			       changed-quality
			       (string-join
				(list
				 (thing-quality changed-thing changed-quality)
				 input-string) ""))])))
#+end_src
*** Add element to thing quality
#+name: add-element-to-thing-quality!-procedure
#+begin_src racket
(define (add-element-to-thing-quality! new-element changed-thing changed-quality)
  (let ([procedure-key (join-strings-and-symbols-as-symbol
			(list "add-element-to-thing-" changed-quality "!"))])
    (cond [(thing-has-procedure? changed-thing procedure-key)
	   ((thing-procedure changed-thing procedure-key) new-element)]
	  [(and (thing-has-universe? changed-thing)
		(universe-has-procedure? (thing-universe changed-thing)
					 procedure-key))
	   ((universe-procedure (thing-universe changed-thing) procedure-key)
	    new-element changed-thing)]
	  [else
	   (set-thing-quality! changed-thing changed-quality
			       (append (thing-quality changed-thing changed-quality)
				       (list new-element)))])))

#+end_src
*** Add elements to thing quality
#+name: add-elements-to-thing-quality!-procedure
#+begin_src racket
(define (add-elements-to-thing-quality! new-elements changed-thing changed-quality)
  (set-thing-quality! changed-thing changed-quality
		      (append (thing-quality changed-thing changed-quality)
			      new-elements)))
#+end_src
*** Remove element from thing quality
#+name: remove-element-from-thing-quality!-procedure
#+begin_src racket
(define (remove-element-from-thing-quality! removed-element changed-thing changed-quality)
  (set-thing-quality! changed-thing changed-quality
		      (remove removed-element
			      (thing-quality changed-thing changed-quality))))

#+end_src
*** Add keyvalue to thing quality
#+name: add-keyvalue-to-thing-quality!-procedure
#+begin_src racket
(define (add-keyvalue-to-thing-quality! new-keyvalue changed-thing changed-quality)
  (hash-set! (thing-quality changed-thing changed-quality)
	     (car new-keyvalue) (cdr new-keyvalue)))
#+end_src
*** Add keyvalues to thing quality
#+name: add-keyvalues-to-thing-quality!-procedure
#+begin_src racket
(define (add-keyvalues-to-thing-quality! new-keyvalues changed-thing changed-quality)
  (map (λ (new-keyvalue)
	 (add-keyvalue-to-thing-quality! new-keyvalue changed-thing changed-quality))
       new-keyvalues))
#+end_src
*** Remove key from thing quality
#+name: remove-key-from-thing-quality!-procedure
#+begin_src racket
(define (remove-key-from-thing-quality! removed-key changed-thing changed-quality)
  (hash-remove! (thing-quality changed-thing changed-quality) removed-key))

#+end_src
** Working with groups of things
*** List thing names
#+name: list-thing-names-procedure
#+begin_src racket

(define (list-thing-names things)
  (oxfordize-list
   (map
    (λ (this-thing)
      (thing-name this-thing))
    things)))
#+end_src
** Engine
*** Make universe logger
#+name: make-universe-logger-procedure
#+begin_src racket
(define (make-universe-logger logging-universe [loglevel 'info])
  (define universe-log
    (make-logger ;(string->symbol (universe-name logging-universe))
     'MUD))
  (define universe-log-receiver
    (make-log-receiver universe-log loglevel))
  (cons universe-log universe-log-receiver))
#+end_src
*** Run universe logger
#+name: run-universe-logger-procedure
#+begin_src racket
(define (run-universe-logger universe-logger)
  (let ([universe-log (car universe-logger)]
	[universe-log-receiver (cdr universe-logger)])
    (current-logger universe-log)
    (thread (λ ()
	      (let log-loop ()
		(define log-vector (sync universe-log-receiver))
		(let ([log-level (vector-ref log-vector 0)]
		      [log-string (substring
				   (vector-ref log-vector 1)
				   5
				   (length (string->list
					    (vector-ref log-vector 1))))])
		  (cond[ (eq? log-level 'debug)
			 (printf ">>> \"~a\"\n"
				 log-string)]
			[else
			 (printf "\"~a\"\n" log-string)]))
		(log-loop))))))
#+end_src
*** Create universe
#+name: create-universe-procedure
#+begin_src racket
    (define (create-universe [name (§ "Universe-"
				      (substring (generate-simple-id)
						 0 3))]
			     [events '()])
      (cond [(string? name)
	     (cond [(list? events)
		    (log-info "Creating universe named ~a" name)
		    (universe name 0 events (list) (make-hash))]
		   [else
		    (raise-argument-error 'create-universe
					  "list?" events)])]
	    [else (raise-argument-error 'create-universe
					"string?" name)]))
#+end_src
*** Tick universe
#+name: tick-universe-procedure
#+begin_src racket
(define (tick-universe ticked-universe)
  (increment-universe-tick-count! ticked-universe)
  (log-debug "Universe ~a is beginning its tick, count #~a" (universe-name ticked-universe) (universe-tick-count ticked-universe))
  (let ([events-this-tick (universe-schedule ticked-universe)])
    (log-debug "Universe ~a is ticking, looking at events: ~a" (universe-name ticked-universe) events-this-tick)
    (set-universe-schedule! ticked-universe '())
    (let loop ()
      (unless (null? events-this-tick)
	(let ([current-event (car events-this-tick)])
          (log-debug "Universe ~a is ticking, looking at event: ~a" (universe-name ticked-universe) current-event)
	  (set! events-this-tick (cdr events-this-tick))
	  (let ([event-result (current-event ticked-universe)])
	    (when (universe? event-result) (set! ticked-universe event-result))))
	(loop))))
  (log-debug "Universe ~a has ended its tick, count #~a" (universe-name ticked-universe) (universe-tick-count ticked-universe))
  ticked-universe)
#+end_src
*** Run universe
#+name: run-universe-procedure
#+begin_src racket
(define (run-universe running-universe [tick-rate 0.2])
  (thread
   (λ () (let loop ()
	   (set! running-universe (tick-universe running-universe))
	   (sleep tick-rate)
	   (loop)))))

#+end_src
*** Create thing
#+name: create-thing-procedure
#+begin_src racket
(define (create-thing [name "thing"] [chosen-universe #f]
		    #:grammar [grammar #f] #:qualities [qualities #f]
		    #:procedures [procedures #f])
  (log-info "Creating a new thing named ~a~a"
	    name
	    (cond [chosen-universe
		   (format "for ~a."
			   (universe-name chosen-universe))]
		  [else "."]))
  (let ([created-thing (thing name chosen-universe
			      (cond [grammar (make-hash grammar)]
				    [else (make-hash)])
			      (cond [qualities (make-hash qualities)]
				    [else (make-hash)])
			      (cond [procedures (make-hash procedures)]
				    [else (make-hash)]))])
    (when chosen-universe
      (add-thing-to-universe-things! created-thing chosen-universe))
    created-thing))
#+end_src
*** Create thing creator for universe
#+name: create-thing-creator-for-universe-procedure
#+begin_src racket

(define (create-thing-creator-for-universe target-universe)
  (λ ([name "thing"] #:grammar [grammar #f] #:qualities [qualities #f]
      #:procedures [procedures #f])
    (create-thing name target-universe
		  #:grammar grammar #:qualities qualities
		  #:procedures procedures)))
#+end_src
* MUDs
* Tests
  :PROPERTIES:
  :header-args: :noweb yes :padline yes
  :END:
** Creating Universes
#+name: creating-universes-test
#+begin_src racket
  (test-case
      "Return of create-universe without arguments is a universe."
    (check-pred universe?
		(create-universe)))

  (test-case
      (§ "Return of create-universe with single string argument "
	 "is universe.")
    (check-pred universe?
		(create-universe "Testverse-One")))

  (test-case
      (§ "Return of create-universe with two arguments, first "
	 "string and second list, is universe.")
    (check-pred universe?
		(create-universe "Testverse-Two" '())))

  (test-case
      (§ "Return of create-universe with non-string first "
	 "argument is contract failure.")
    (check-exn exn:fail:contract?
	       (λ () (create-universe 'Failverse))))

  (test-case
      (§ "Return of create-universe with non-list second "
	 "argument is contract failure.")
    (check-exn exn:fail:contract?
	       (λ () (create-universe "Testverse-Null" 'fail))))
#+end_src
** Renaming a Universe
* Files
  :PROPERTIES:
  :header-args: :noweb yes :padline yes
  :END:
** test-qtmud.rkt
#+name: test-qtmud.rkt
#+begin_src racket :tangle ./test-qtmud.rkt
  #lang racket

  (require rackunit
	   "qtmud.rkt")

  (provide qtmud-tests)

(define qtmud-tests
  (test-suite
   "Tests for the qtMUD Racket module."

<<creating-universes-test>>

))
#+end_src
** test-everything.rkt
#+name: test-everything.rkt
#+begin_src racket :tangle ./test-everything.rkt
    #lang racket

    (require rackunit
	     rackunit/text-ui
	     "qtmud.rkt"
	     "test-qtmud.rkt"
	     "library/test-animation.rkt")

    (run-qtmud-logger (make-qtmud-logger))

    (map
     (λ (suite)
       (display (format "Running ~a\n  "
		      (rackunit-test-suite-name suite)))
       (run-tests suite))
     (list
      qtmud-tests
      animation-tests))
#+end_src
** qtmud.rkt
#+name: qtmud.rkt
#+begin_src racket :noweb yes :tangle ./qtmud.rkt
  #lang racket

  (require racket/serialize)

  (require uuid)

  (provide (struct-out universe)
	   (struct-out thing)
	   §
	   deserialize-file
	   oxfordize-list
	   join-strings-and-symbols-as-symbol
	   make-qtmud-logger
	   run-qtmud-logger
           generate-simple-id
	   increment-universe-tick-count!
	   add-event-to-universe-schedule!
	   add-thing-to-universe-things!
	   universe-has-procedure?
	   universe-procedure
	   set-universe-procedure!
	   add-procedures-to-universe!
	   thing-has-universe?
	   thing-has-quality?
	   thing-quality
	   set-thing-quality!
	   add-string-to-thing-quality!
	   add-element-to-thing-quality!
	   add-elements-to-thing-quality!
	   remove-element-from-thing-quality!
	   add-keyvalue-to-thing-quality!
	   add-keyvalues-to-thing-quality!
	   remove-key-from-thing-quality!
	   thing-has-procedure?
	   thing-procedure
	   list-thing-names
	   make-universe-logger
	   run-universe-logger
	   create-universe
	   tick-universe
	   run-universe
	   create-thing
	   create-thing-creator-for-universe)

  <<§-procedure>>
  <<deserialize-file-procedure>>
  <<symbols->strings-procedure>>
  <<oxfordize-list-procedure>>
  <<join-strings-and-symbols-as-symbol-procedure>>
  <<make-qtmud-logger-procedure>>
  <<run-qtmud-logger-procedure>>
  <<generate-simple-id-procedure>>

  <<universe-struct>>
  <<increment-universe-tick-count!-procedure>>
  <<add-event-to-universe-schedule!-procedure>>
  <<add-thing-to-universe-things!-procedure>>
  <<universe-has-procedure?-procedure>>
  <<universe-procedure-procedure>>
  <<set-universe-procedure!-procedure>>
  <<add-procedures-to-universe!-procedure>>

  <<thing-struct>>
  <<thing-has-procedure?-procedure>>
  <<thing-has-quality?-procedure>>
  <<thing-has-universe?-procedure>>
  <<thing-quality-procedure>>
  <<set-thing-quality!-procedure>>
  <<add-string-to-thing-quality!-procedure>>
  <<add-element-to-thing-quality!-procedure>>
  <<add-elements-to-thing-quality!-procedure>>
  <<remove-element-from-thing-quality!-procedure>>
  <<add-keyvalue-to-thing-quality!-procedure>>
  <<add-keyvalues-to-thing-quality!-procedure>>
  <<remove-key-from-thing-quality!-procedure>>
  <<thing-procedure-procedure>>
  <<list-thing-names-procedure>>
  <<make-universe-logger-procedure>>
  <<run-universe-logger-procedure>>
  <<create-universe-procedure>>
  <<tick-universe-procedure>>
  <<run-universe-procedure>>
  <<create-thing-procedure>>
  <<create-thing-creator-for-universe-procedure>>
#+end_src
